<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法分析与设计基础第3版</title>
      <link href="/posts/35662/"/>
      <url>/posts/35662/</url>
      
        <content type="html"><![CDATA[<h1 id="算法分析与设计基础第3版"><a href="#算法分析与设计基础第3版" class="headerlink" title="算法分析与设计基础第3版"></a>算法分析与设计基础第3版</h1> <embed src="/pdf/算法分析与设计基础3.pdf" width="100%" height="750" type="application/pdf"> ]]></content>
      
      
      <categories>
          
          <category> book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法设计与分析基础笔记</title>
      <link href="/posts/18798/"/>
      <url>/posts/18798/</url>
      
        <content type="html"><![CDATA[<h4 id="递归算法数序分析"><a href="#递归算法数序分析" class="headerlink" title="递归算法数序分析"></a>递归算法数序分析</h4><p>在计算一些常用算法的时间复杂度时，经常涉及到递归，因此也就离不开递归算法的分析</p><h4 id="先看一个例子"><a href="#先看一个例子" class="headerlink" title="先看一个例子"></a>先看一个例子</h4><p>计算函数的时间复杂度</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n*f(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面函数的基本操作就是做乘法，所以计算函数的时间复杂度，其实就是计算<strong>乘法的操作次数。</strong></p><p>假设M(n)代表传入参数n时，函数进行乘法操作的次数，所以有</p><script type="math/tex; mode=display">M(n)= \begin{cases}0\quad\textcolor{orange}{n=0};  \\M(n-1)+1\quad\textcolor{orange}{n>0};\\\end{cases}</script><p>其中加1是指将n乘以f(n-1)。所以根据上面的公式得</p><script type="math/tex; mode=display">\begin{aligned}M(n)&=M(n-1)+1\\&=M(n-2)+1+1\\  &=M(n-3)+1+1+1\\&=M(n-4)+1+1+1+1\\&=···\\&=M(0)+n\\&=n \\  \end{aligned}</script><p>$\begin{aligned}<br> 时间复杂度    \textcolor{red}{O(n)=n}<br>\end{aligned} $</p><h5 id="进行递归算法分析的主要步骤"><a href="#进行递归算法分析的主要步骤" class="headerlink" title="进行递归算法分析的主要步骤"></a>进行递归算法分析的主要步骤</h5><ul><li>确定输入参数的规模</li><li>找出基本操作</li><li>分析相同规模不同输入的算法的最优、最差、平均效率差别</li><li>建立递推关系</li><li>解递推式</li></ul><h4 id="汉诺塔递归算法分析"><a href="#汉诺塔递归算法分析" class="headerlink" title="汉诺塔递归算法分析"></a>汉诺塔递归算法分析</h4><blockquote><p>汉诺塔游戏是将n个盘子通过一个中间柱子，移动到第三个柱子，规则就是小盘子必须在大盘子上面。</p><p><img src="/pic/算法笔记/image-20230801112714469.png" alt="image-20230801112714469"></p><p>问题可以分解成三步，先将上面的n-1个盘子移动到第二根柱子，然后把最大的盘子移动到第三根柱子，最后把n-1个盘子移动到第三根柱子。假设$M(n)$表示将n个盘子移动到第三根柱子需要的步骤数，所以有以下递推式</p><script type="math/tex; mode=display">\begin{aligned} &M(n)=M(n-1)+1+M(n-1) \\&M(n)=2M(n-1)+1\\\\&M(n)= \begin{cases}1\quad\textcolor{orange}{n=1};  \\\\2M(n-1)+1\quad\textcolor{orange}{n>0};\\\end{cases}\end{aligned}</script><p>所以有</p><script type="math/tex; mode=display">\begin{aligned} \textcolor{green}{M(n)}&=2M(n-1)+1\\&=2^2M(n-2)+1+2^1\\&=2^3M(n-3)+1+2^1+2^2\\&=2^4M(n-4)+1+2^1+2^2+2^3\\&=···\\&=2^{n-1}M(1)+1+2+2^2+2^3+···2^{n-2}\\&=2^{n-1}+\frac{1-2^{n-1}}{1-2}\\&=2^{n-1}+2^{n-1}-1\\&=\textcolor{red}{2^n-1}\\\\时间复杂度：\textcolor{red}{O(n)=2^n}\end{aligned}</script></blockquote><h4 id="再看一个例子"><a href="#再看一个例子" class="headerlink" title="再看一个例子"></a>再看一个例子</h4><p>计算时间复杂度</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f(n/<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>这种类型的不能用反向替换方法，如果像 <script type="math/tex">M(n)=M(\frac{n}{2})+1 \\\space\space M(\frac{n}{2})=M(\frac{n}{4})+1</script>  这样替换下去，n不是2的乘方的话，终止不了的。只能在n为2的k次方的情况下求解递推式，所以假设 $n=2^k$ </p></blockquote><p>上公式</p><script type="math/tex; mode=display">\begin{aligned}&令 n=2^k  \\{\space\space}&M(n)=M(\frac{n}{2})+1  \\&=>M(2^k)=M(2^{k-1})+1  \\&M(1)=0\\\end{aligned}\begin{aligned} M(2^k)&=M(2^{k-1})+1 \\&=M(2^{k-2})+1+1\\&=M(2^{k-3})+1+1+1\\&=···\\&=M(2^{k-k})+1+1+···+1+1+1\\&=M(1)+k\\&=\textcolor{red}{k}\\2^k=n {\space\space}即{\space\space}k=log_2n{\space\space} 所以M(n)=log_2n\\时间复杂度：\textcolor{red}{O(n)=log_2n}\end{aligned}</script><p>其他的$\frac{n}{3},\frac{n}{4}$都是一样的道理</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法设计与分析基础笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>project</title>
      <link href="/posts/3210/"/>
      <url>/posts/3210/</url>
      
        <content type="html"><![CDATA[<h4 id="课程预览"><a href="#课程预览" class="headerlink" title="课程预览"></a>课程预览</h4><p><img src="/pic/xuecheng/image-20230731165620030.png" alt="image-20230731165620030"></p><ol><li>前端通过通过点击课程的预览按钮，进入预览页面。前端传递课程id,访问内容管理服务的CoursePublishController,根据课程id，将课程的师资信息，营销信息、基本信息、课程计划信息查询并组装。</li><li>组装后的信息通过freemarker模版引擎将数据渲染到course_template.ftl上，然后返回给前端。</li><li>进入预览页面，查看视频，会发送两次请求，先根据课程id到内容管理服务的CourseOpenController查询课程信息，这里调用的查询方法和第一步一样（没必要差这么全吧）。第二次将课程计划绑定的媒资id发送媒资管理服务的MediaOpenController，查询媒资的访问url，返回前端，以便播放。</li></ol><h4 id="课程提交审核"><a href="#课程提交审核" class="headerlink" title="课程提交审核"></a>课程提交审核</h4><ol><li><p>为实现审核过程中可以修改，设计了课程预发布表，机构人员可以随意修改课程计划、课程基本信息等。提交时，将这些信息组合起来存入预发布表。审核人员审核预发布表中的内容，审核中时，要把预发布表中的审核状态设置为审核中。</p></li><li><p>点击提交课程，传递课程id，访问CoursePublishController的方法，将课程的各种信息组装起来存入课程预发布表。存入课程预发布表时要先判断课程信息是否完备，完备后，查询预发布表中信息，看是否存在了，若存在，要看课程的审核状态，如果是审核中，则不可再提交，否则，对存在的信息进行更新操作，不存在就直接插入。然后修改课程基本信息表中的状态为审核中</p></li><li><p>由于进行了预发布表的插入和课程基本信息表的修改，要加上事务控制。</p><p>课程有两个状态一个审核状态{添加课程成功未提交审核   状态为“已提交”，提交审核了  “已提交”，审核通过了  “审核通过”，审核不通过 “审核不通过”}  一个发布状态{目前不清楚}        课程预发布表中有一个审核状态 {提交审核存进来的，初始都为 “已提交”，其他类似，只是没有未提交这个状态}</p></li></ol><h4 id="课程发布"><a href="#课程发布" class="headerlink" title="课程发布"></a>课程发布</h4><h5 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h5><blockquote><p>分布式系统把一个应用系统拆分成分多个可独立部署的微服务，不同微服务间通过网络远程协作（调用）完成的事务操作就是分布式事务。</p><p><strong><em><u>注</u></em></strong></p><p>我之前一直以为只要是连的同一个主机的mysql，@Transaction就能控制事务。只要操作了不同的数据库（这个是指mysql中创建的database，不是指mysql本身，mysql属于数据库管理系统层面）就是分布式事务。<strong><em><u>但注意</u></em></strong>，如果是两个微服务连接的同一个数据库，也属于分布式事务，原因就是跨JVM进程，两个微服务持有了不同的数据库链接进行数据库操作，此时产生分布式事务。</p></blockquote><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><ul><li><p>课程审核成功后，需要将预发布表中的信息复制到发布表。</p></li><li><p>课程发布成功后，是可以被搜索到的，并且会有大量用户搜索。因此要把发布成功的信息存到  redis、es、minio。其中redis和es都是存课程信息，minio里面存渲染后的课程静态页面。</p></li><li><p>保存已发布课程的信息涉及到多个操作，涉及到分布式事务，用transaction是不行的。</p></li></ul><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><blockquote><p>首先要考虑是AP还是CP（CAP理论），此处只说保证AP也就是最终一致性的解决方法。</p></blockquote><p>使用XXL-Job+数据库表方案，当把发布的课程存入发布表后，再将课程存入消息表，此处是可以使用注解保证课程发布成功，消息表一定有数据。然后开启定时任务调度，将消息表中的数据取出依次完成存入redis、es、minio等操作，就算远程调用过程中出现问题，由于是定时调度，并且消息表中的数据还在，故可以保证最终一致性。</p><h5 id="消息SDK组件内容补充"><a href="#消息SDK组件内容补充" class="headerlink" title="消息SDK组件内容补充"></a>消息SDK组件内容补充</h5><blockquote><p>消息组件提供一套解决对消息的增删改查业务的方案，就是向外提供接口，但是不没有具体执行逻辑</p></blockquote><p>消息表中主要就是保存业务的主要信息。如该项目中保存的是课程的id，通过拿到消息表中的课程id，就能查询到课程信息，然后进行缓存操作。消息表中的业务字段有多个，用不上的给该字段存null就行。消息表中还有多个状态字段。因为要存到redis、es、minio，每个阶段完成后给对应字段标记，可以减少重复执行。</p><h4 id="补充关于XXL-Job使用分布式锁防止重复执行方案"><a href="#补充关于XXL-Job使用分布式锁防止重复执行方案" class="headerlink" title="补充关于XXL-Job使用分布式锁防止重复执行方案"></a>补充关于XXL-Job使用分布式锁防止重复执行方案</h4><blockquote><p>xxl-job调度进行视频转码时，用了乐观锁的方案进行避免重复执行，因为视频转码比较消耗CPU，因此应该尽量避免重复执行，而对于缓存操作，不是特别消耗CPU（视频中老师说的）</p></blockquote><h5 id="使用xxl-job时，不是配置了调度策略嘛，为什么还要用乐观锁？"><a href="#使用xxl-job时，不是配置了调度策略嘛，为什么还要用乐观锁？" class="headerlink" title="使用xxl-job时，不是配置了调度策略嘛，为什么还要用乐观锁？"></a>使用xxl-job时，不是配置了调度策略嘛，为什么还要用乐观锁？</h5><p>老师是这样解释的，当执行器与调度器之间的连接发生了中断，xxl-job就检测不到这个执行器了，虽然是发生了中断，但是执行器可能在执行任务了（执行任务时，连接中断了）。由于xxl-job是动态扩容，因此会对其他执行器进行重新排序（代码每个执行器就是根据自己的序号进行对应任务的处理），那么就导致其他执行器会调度执行（在断开连接的执行器执行完任务，删除任务表中数据之前）任务表中的任务，就有可能重复执行。</p><h4 id="页面静态化"><a href="#页面静态化" class="headerlink" title="页面静态化"></a>页面静态化</h4><blockquote><p>对于课程预览页面，用户搜索到就能查看，如果每次都访问tomcat服务器查询数据渲染返回，会使服务器压力过大，因此需要对课程预览页进行静态化并存储到minio。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> xuecheng </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/posts/d87f7e0c/"/>
      <url>/posts/d87f7e0c/</url>
      
        <content type="html"><![CDATA[<h3 id="这是测试用例"><a href="#这是测试用例" class="headerlink" title="这是测试用例"></a>这是测试用例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;hello java&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="ReentrantLock和Synchronized的区别"><a href="#ReentrantLock和Synchronized的区别" class="headerlink" title="ReentrantLock和Synchronized的区别"></a>ReentrantLock和Synchronized的区别</h3><ul><li>ReentrantLock是一个类。synchronized是一个Java关键字</li><li>前者可重入 后者不可重入</li><li>前者获取锁失败可以返回  后者会阻塞</li><li>前者需要手动释放锁  后者自动释放锁</li></ul><h4 id="如何在4小时内睡满8小时"><a href="#如何在4小时内睡满8小时" class="headerlink" title="如何在4小时内睡满8小时"></a>如何在4小时内睡满8小时</h4><blockquote><p>这是一个智障问题</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156/"/>
      <url>/posts/4a17b156/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
