<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>二叉树笔记</title>
      <link href="/posts/5455/"/>
      <url>/posts/5455/</url>
      
        <content type="html"><![CDATA[<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><blockquote><h4 id="平衡二叉树也叫做AVL树，任意一个节点的左右子树高度之差不超过1"><a href="#平衡二叉树也叫做AVL树，任意一个节点的左右子树高度之差不超过1" class="headerlink" title="平衡二叉树也叫做AVL树，任意一个节点的左右子树高度之差不超过1"></a>平衡二叉树也叫做AVL树，任意一个节点的左右子树高度之差不超过1</h4></blockquote><h1 id="2-3-4树"><a href="#2-3-4树" class="headerlink" title="2-3-4树"></a>2-3-4树</h1><blockquote><h2 id="2-3-4树不属于二叉树-一个2-3-4树可以对应多个红黑树，但一个红黑树只对应一个2-3-4树"><a href="#2-3-4树不属于二叉树-一个2-3-4树可以对应多个红黑树，但一个红黑树只对应一个2-3-4树" class="headerlink" title="2-3-4树不属于二叉树   一个2-3-4树可以对应多个红黑树，但一个红黑树只对应一个2-3-4树"></a>2-3-4树不属于二叉树   一个2-3-4树可以对应多个红黑树，但一个红黑树只对应一个2-3-4树</h2></blockquote><h2 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h2><ul><li><h3 id="所有叶子结点的高度相同"><a href="#所有叶子结点的高度相同" class="headerlink" title="所有叶子结点的高度相同"></a>所有叶子结点的高度相同</h3></li><li><h3 id="节点的类型必须是2节点、3节点、4节点"><a href="#节点的类型必须是2节点、3节点、4节点" class="headerlink" title="节点的类型必须是2节点、3节点、4节点"></a>节点的类型必须是2节点、3节点、4节点</h3><ul><li><h4 id="2节点就是节点中只有1个元素，有2个子节点"><a href="#2节点就是节点中只有1个元素，有2个子节点" class="headerlink" title="2节点就是节点中只有1个元素，有2个子节点"></a>2节点就是节点中只有1个元素，有2个子节点</h4></li><li><h4 id="3节点就是节点中只有2个元素，有3个子节点"><a href="#3节点就是节点中只有2个元素，有3个子节点" class="headerlink" title="3节点就是节点中只有2个元素，有3个子节点"></a>3节点就是节点中只有2个元素，有3个子节点</h4></li><li><h4 id="4节点就是节点中只有3个元素，有4个子节点"><a href="#4节点就是节点中只有3个元素，有4个子节点" class="headerlink" title="4节点就是节点中只有3个元素，有4个子节点"></a>4节点就是节点中只有3个元素，有4个子节点</h4></li></ul></li></ul><h2 id="2-3-4树的构造"><a href="#2-3-4树的构造" class="headerlink" title="2-3-4树的构造"></a>2-3-4树的构造</h2><blockquote><h4 id="2-3-4树是从下往上生长。这里我们以数组-1-2-3-4-5-6-7-8-9-为例子，来描述一下构造的主要过程。新节点的插入都是进行结合操作，结合后进行调整。"><a href="#2-3-4树是从下往上生长。这里我们以数组-1-2-3-4-5-6-7-8-9-为例子，来描述一下构造的主要过程。新节点的插入都是进行结合操作，结合后进行调整。" class="headerlink" title="2-3-4树是从下往上生长。这里我们以数组{1,2,3,4,5,6,7,8,9}为例子，来描述一下构造的主要过程。新节点的插入都是进行结合操作，结合后进行调整。"></a>2-3-4树是从下往上生长。这里我们以数组{1,2,3,4,5,6,7,8,9}为例子，来描述一下构造的主要过程。新节点的插入都是进行结合操作，结合后进行调整。</h4></blockquote><ol><li>最开始元素1成为根节点，节点类型属于2节点。</li><li>元素2寻找插入位置，是元素1的右边，那么元素2就会元素1结合，此处由于结合后是3节点类型，不需要进行其他操作。</li><li>元素3寻找插入位置，是元素2的右边，那么元素3与元素1和元素2结合形成了一个4节点类型，也是不需要进行其他操作。</li><li>元素4也来了，他也要与元素1、2、3结合在一起，那么这时候就是一个4节点了，不符合2-3-4树，因此进行一次“提升”操作，将原来的4节点中的中间元素往上提升，变成一个2节点左连一个2节点，右连一个3节点。</li><li>元素5也来了，要与元素3、4结合，结合成功。</li><li>元素6也来了，要与元素3、4、5结合，结合和对元素4进行提升，提升的元素4与元素1进行 结合。</li><li>….</li></ol><p><img src="/pic二叉树/image-20230803153020368.png" alt="image-20230803153020368"></p><p><img src="/pic二叉树/image-20230803152954496.png" alt="image-20230803152954496"></p><p><img src="/pic二叉树/image-20230803153059658.png" alt="image-20230803153059658"></p><p><img src="/pic二叉树/image-20230803153304704.png" alt="image-20230803153304704"></p><p><img src="/pic二叉树/image-20230803153348719.png" alt="image-20230803153348719"></p><p><img src="/pic二叉树/image-20230803153633873.png" alt="image-20230803153633873"></p><p><img src="/pic二叉树/image-20230803153736448.png" alt="image-20230803153736448"></p><p><img src="/pic二叉树/image-20230803154247579.png" alt="image-20230803154247579"></p><p><img src="/pic二叉树/image-20230803154321726.png" alt="image-20230803154321726"></p><p><img src="/pic二叉树/image-20230803154850998.png" alt="image-20230803154850998"></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><blockquote><h3 id="在构造的过程中，就是先一直结合，结合成一个4节点类型，当再过来元素想要结合时，就要将4节点类型进行分裂。分裂的操作就是将原来中间元素提升，剩下的两部分形成一个2型节点和3型节点，而被提升的元素会尝试与它同层的节点也进行相同的结合操作。"><a href="#在构造的过程中，就是先一直结合，结合成一个4节点类型，当再过来元素想要结合时，就要将4节点类型进行分裂。分裂的操作就是将原来中间元素提升，剩下的两部分形成一个2型节点和3型节点，而被提升的元素会尝试与它同层的节点也进行相同的结合操作。" class="headerlink" title="在构造的过程中，就是先一直结合，结合成一个4节点类型，当再过来元素想要结合时，就要将4节点类型进行分裂。分裂的操作就是将原来中间元素提升，剩下的两部分形成一个2型节点和3型节点，而被提升的元素会尝试与它同层的节点也进行相同的结合操作。"></a>在构造的过程中，就是先一直结合，结合成一个4节点类型，当再过来元素想要结合时，就要将4节点类型进行分裂。分裂的操作就是将原来中间元素提升，剩下的两部分形成一个2型节点和3型节点，而被提升的元素会尝试与它同层的节点也进行相同的结合操作。</h3></blockquote><h2 id="2-3-4树的节点与红黑树的等价关系"><a href="#2-3-4树的节点与红黑树的等价关系" class="headerlink" title="2-3-4树的节点与红黑树的等价关系"></a>2-3-4树的节点与红黑树的等价关系</h2><p><img src="/pic二叉树/image-20230803161442907.png" alt="image-20230803161442907"></p><p>第四种状态是裂变时的状态，对于红黑树而言，新插入进来的节点都是红节点。</p><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><blockquote><h4 id="红黑树也叫做RBT树，是一种自平衡树，没有平衡树二叉树那样严格的平衡条件。红黑树从2-3-4树演变而来。可以根据2-3-4树倒推红黑树的5条性质"><a href="#红黑树也叫做RBT树，是一种自平衡树，没有平衡树二叉树那样严格的平衡条件。红黑树从2-3-4树演变而来。可以根据2-3-4树倒推红黑树的5条性质" class="headerlink" title="红黑树也叫做RBT树，是一种自平衡树，没有平衡树二叉树那样严格的平衡条件。红黑树从2-3-4树演变而来。可以根据2-3-4树倒推红黑树的5条性质"></a>红黑树也叫做RBT树，是一种自平衡树，没有平衡树二叉树那样严格的平衡条件。红黑树从2-3-4树演变而来。可以根据2-3-4树倒推红黑树的5条性质</h4></blockquote><h2 id="性质推导"><a href="#性质推导" class="headerlink" title="性质推导"></a>性质推导</h2><p>因为红黑树可以由2-3-4树演变得来，也就是说2-3-4树满足的性质，也就是红黑树满足的性质。首先，<strong>根据2-3-4树的 “叶子节点高度相同”</strong>，所以可以<strong>推出“从每一个根节点到其所有的叶子节点的路径长度相同”</strong>，然后根据我们的上图中2-3-4树节点的等价关系，每一个2-3-4树节点的等价关系都包含了一个黑色节点，由于路径相等，<strong>所以每一个根节点到叶子节点的路径上黑色节点个数相等</strong>。其他性质也能根据推出，这里不再推了</p><h2 id="相互转换"><a href="#相互转换" class="headerlink" title="相互转换"></a>相互转换</h2><blockquote><h3 id="把下面这个红黑树转换成2-3-4树，（N是代表空指针，作为一个黑色叶子节点，一般是不画出来的）"><a href="#把下面这个红黑树转换成2-3-4树，（N是代表空指针，作为一个黑色叶子节点，一般是不画出来的）" class="headerlink" title="把下面这个红黑树转换成2-3-4树，（N是代表空指针，作为一个黑色叶子节点，一般是不画出来的）"></a>把下面这个红黑树转换成2-3-4树，（N是代表空指针，作为一个黑色叶子节点，一般是不画出来的）</h3><p><img src="二叉树.assets/image-20230803163203632.png" alt="image-20230803163203632"></p><p>就是找出等价关系中匹配的子树形状，其中14和5是符合3节点类型，所以就是{5,14}，20和25也是符合3节点类型，所以也是{20,25}，所以就 </p></blockquote><h2 id="红黑树的删除操作"><a href="#红黑树的删除操作" class="headerlink" title="红黑树的删除操作"></a>红黑树的删除操作</h2><p>红黑树的删除操作一定要与2-3-4树进行对应，不然是非常难理解的。这里先再次说明一下2-3-4树的性质</p><p>2-3-4树的重要性质</p><ul><li><p>2-3-4树的节点必须是  2节点\3节点\4节点中的类型</p></li><li><p>2-3-4树一定是一颗完全树，每个节点必须满足它的要求（除开叶子结点外），即2节点就必须有两个孩子，3节点就必须有三个孩子….。且叶子节点全部在同一高度</p></li><li>2-3-4树与红黑树的对应关系 中，一个2-3-4树节点有且仅有一个黑色节点。</li><li>2-3-4树与红黑树的对应关系中，黑色节点一定是在红色节点之上</li><li>2-3-4树的插入操作一定是在叶子节点上插入，因为它是往上长的，只有底下先变成4节点类型，才会把节点中间元素往上挤</li></ul><h3 id="思路（有重点）"><a href="#思路（有重点）" class="headerlink" title="思路（有重点）"></a>思路（有重点）</h3><blockquote><p>黑红树节点的删除是通过寻找被删除节点的前驱节点或者后继节点 ，是用前驱或后继节点替代被删除的节点。但是我们需要先对被删除节点进行以下情况分析。包括以下情况</p><ul><li>被删除节点没有左右孩子。</li><li>被删除节点只有一个孩子</li><li>被删除节点有两个孩子</li></ul><p>前两种的删除操作其实并不难，没有孩子的节点直接删除。有一个孩子的节点，把节点删了后，用子节点顶替被删了的父节点即可。而有两个孩子就不好搞了，这就要找前驱或者后继了。而前驱节点或者后继节点有什么性质？显然前驱节点和后继节点就是前两种情况！所以我们需要先将有两个孩子的情况处理一下，找到后继节点其实情况就统一了，就是删除没有孩子的节点或者有一个孩子的节点。</p><p>最开始提到过，红黑树的删除操作是要对比2-3-4树的。既然我们明确了要删什么节点，那么我们可以在进一步分析一下下面这个问题。</p><p><strong>红黑树中只有一个孩子的节点，在2-3-4树中是个什么情况？ 没有孩子的节点呢？</strong></p><p>根据我最开始说的2-3-4树的性质，2-3-4树中除了叶子节点，每个节点的孩子数量满足节点类型，所以，红黑树中没有孩子的节点只可能出现在2-3-4树叶子节点的2型、3型、4型节点中。而一个孩子的节点，只能出现在2-3-4树叶子结点的3型节点中。</p><p>如果实在想不明白，你就自己画一个2-3-4树，然后转换成红黑树，很明显叶子结点的2型、3型和4型都会出现单独的一个节点，而3型才会出现只有一个孩子的节点的情况。</p><p>单纯删掉节点删除容易，但是要确保红黑树平衡却不简单，我们继续分析以下问题</p><p><strong>没有孩子的节点，颜色有哪些情况？</strong></p><p>这个其实还简单，根据上一个问题的分析，1型和4型才会出现无孩子节点的情况，其中1型节点本就规定是黑色，而4型节点是上面一个黑色，两边各一个且都是红色。所以没有孩子的节点  有红黑两种情况</p><p><strong>只有一个孩子的节点，颜色情况有哪些？</strong></p><p>这个同理，只有3型节点，上黑下红，肯定就是上面那个黑的了，所以只有黑色情况</p><p><strong>删掉哪种类型节点破坏平衡？</strong></p><p>红黑树平衡是指黑色节点的平衡，删掉了黑色节点属于破坏平衡。</p><p>分析到这里就差不多可以开始写代码了 再补充一个其他知识，<strong>要把红黑树变成2-3-4树，只需要把红色节点提到它的父节点上就行</strong></p></blockquote><p>待续。。。</p><p>后继：</p><ul><li>没有孩子<ul><li>红色叶子    不用修改</li><li>黑夜叶子     找兄弟借</li></ul></li><li>有孩子   （只能是右孩子，但是不重要  重要的是与2-3-4数进行对应）<ul><li>只有一个孩子的节点</li></ul></li></ul><p>原来：</p><ul><li><p>有孩子</p><ul><li>左孩子</li></ul></li></ul><ul><li>右边孩子</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型笔记</title>
      <link href="/posts/35767/"/>
      <url>/posts/35767/</url>
      
        <content type="html"><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><blockquote><p>定义形式    <strong>修饰符   class  类名 \&lt; T,K,V…<font&gt;></font> {}</strong>      其中T,K,V是自定义的随便写什么，但一般建议就写K、V、T等一个大写字母，毕竟本身含义就是泛型，没必要用特殊的标识符啥的定义。<strong><T,K,V></strong>两边的空格数没有规定，连在一起或者分开都行  一般就与类名挨着，与左大括号间隔一个空格。泛型只在编译阶段起作用，运行阶段不起作用</p></blockquote><h3 id="定义与使用"><a href="#定义与使用" class="headerlink" title="定义与使用"></a>定义与使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ljb;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李家宝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/7/30 15:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&lt;T&gt; &#123;</span><br><span class="line">    T name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(T name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Test&lt;String&gt; test = <span class="keyword">new</span> <span class="title class_">Test</span>&lt;&gt;();</span><br><span class="line">        test.setName(<span class="string">&quot;李家宝&quot;</span>);</span><br><span class="line">        System.out.println(test.getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类定义了泛型后，成员变量和成员方法就可以使用这个泛型了。在创建Test对象时，可以指定具体类型，上面的代码中就是指定T为String类型，那么Test类中的name也就是String类型了。Getter和Setter方法中的T也就是String类型了。但是如果没有指定，则T默认为Object类型</p><p>指定String类型</p><p><img src="/pic/泛型/image-20230804005334196.png" alt="image-20230804005334196"></p><p>未指定类型</p><p><img src="/pic/泛型/image-20230804005244438.png" alt="image-20230804005244438"></p><p>未指定具体类型时，Getter得到的也是Object类型对象，使用获取到的返回对象时就要进行强转。一般使用泛型类时是需要指定类型的，你不指定，就没有必要用泛型，我直接把类的成员变量和成员方法返回值全定义成Object类型不就是了。</p><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><blockquote><p>定义形式  <strong>修饰符 <T,K,V...> 返回类型 方法名(参数列表){}</strong></p></blockquote><h3 id="定义与使用-1"><a href="#定义与使用-1" class="headerlink" title="定义与使用"></a>定义与使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ljb;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李家宝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/7/30 15:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&lt;T&gt; &#123;</span><br><span class="line">    T name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(T name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个T和类上面定义的不是同一个</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T,K,V&gt; T <span class="title function_">returnObj</span><span class="params">(T t,K k)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Test&lt;Integer&gt; test = <span class="keyword">new</span> <span class="title class_">Test</span>&lt;&gt;();</span><br><span class="line">        <span class="type">String</span> <span class="variable">ljb</span> <span class="operator">=</span> test.returnObj(<span class="string">&quot;ljb&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        test.setName(<span class="number">20</span>);</span><br><span class="line">        System.out.println(ljb);</span><br><span class="line">        System.out.println(test.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要看上面的<strong>19-20行</strong> 首先要明白泛型方法和非泛型方法的区别，泛型方法有一个  <T,K,V> 这个相当于一个声明列表，和类上面那个一个意思。定义了这个泛型列表，形参中才能用这些类型。泛型的实际类型是根据传递过来的参数进行确定。方法就会根据调用时递的实际类型进行相关操作，但注意，<strong>是编译时期就会进行处理，并不是等到真正运行调用是才确定K，T，V它们的类型。</strong></p><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>在上面的代码中，我故意把泛型方法returnObj的返回类型也写成了T，但这个T和类上那个T不是同一个T。就是说创建对象时如果指定泛型为String，并不意味着我的泛型方法返回值就是String。但是如果我的泛型方法泛型列表中没有定义T，那么这个T就是类上的T。（在代码中ctrl+左键点过去）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>泛型类是在类上声明一个泛型列表 就是  <K,V,T..>  里面的个数至少一个。然后类中的成员变量就可以直接用这个泛型，而泛型的具体类型是创建对象时指定。</p><p>泛型方法是在方法上声明一个泛型列表 就是  <K,V,T..>  里面的个数至少一个。然后参数列表中的变量就可以直接用这个泛型，而泛型的具体类型是传递参数时指定。</p><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><blockquote><p>泛型接口和泛型类类似的。</p></blockquote><p>有个要注意的点，泛型接口的实现类和实现接口时，如果没有声明泛型，实现接口的方法时，不管是泛型方法还是非泛型方法，泛型返回值会默认成Object类型，像下面这样   <strong>public class Test implements JK1</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ljb;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李家宝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/7/30 15:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">implements</span> <span class="title class_">JK1</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">print1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">JK1</span>&lt;T&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这个T是接口上的T</span></span><br><span class="line">    T <span class="title function_">print1</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个T是泛型方法的T，与接口上的T没关系</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实现接口时如果指定了接口泛型的具体类型，那么实现的方法类型就是指定的类型，注意接口中的泛型方法的泛型不一定是指定的类型。泛型方法的注意那里讲了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ljb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.generic.NEW;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李家宝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/7/30 15:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">implements</span> <span class="title class_">JK1</span>&lt;String&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">print</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">print1</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">JK1</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个T是接口上的T</span></span><br><span class="line">    T <span class="title function_">print</span><span class="params">(T t)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个T是泛型方法的T，与接口上的T没关系</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">print1</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面两种情况的代码，实现类并没有声明泛型列表，可以写也可以不写，随便写什么字母，并且与接口没关系。但如果实现接口时，还是将接口指定为泛型，那么实现类就必须要写泛型列表，并且列表中必须有一个与接口泛型相同的字母（泛型名）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ljb;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李家宝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/7/30 15:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&lt;T,K,V&gt; <span class="keyword">implements</span> <span class="title class_">JK1</span>&lt;K&gt;&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">print1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">JK1</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个T是接口上的T</span></span><br><span class="line">    T <span class="title function_">print1</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个T是泛型方法的T，与接口上的T没关系</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，在创建实现类对象时，确定接口泛型具体类型。</p><h2 id="类型通配符-“-？”"><a href="#类型通配符-“-？”" class="headerlink" title="类型通配符 “ ？”"></a>类型通配符 “ ？”</h2><blockquote><p>有一个需求，要求定义一个方法  要能处理以下两个种类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">由于markdown识别不了尖括号&lt;&gt; 因此我写在代码块中</span></span><br><span class="line"><span class="comment">List&lt;Integer&gt; </span></span><br><span class="line"><span class="comment">List&lt;Float&gt;</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure></blockquote><p>没学泛型之前，想到的办法可能就是进行重载，但是此处会有问题。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ljb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李家宝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/7/30 15:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public static void fun1(List&lt;Number&gt; list) &#123;</span></span><br><span class="line"><span class="comment">//        //只能获取元素  返回Object类型  但无法对o进行强转  因为不知道List中的具体类型</span></span><br><span class="line"><span class="comment">//        Number number = list.get(0);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">(List&lt;Float&gt; list)</span> &#123;</span><br><span class="line">        <span class="comment">//只能获取元素  返回Object类型  但无法对o进行强转  因为不知道List中的具体类型</span></span><br><span class="line">        <span class="type">Float</span> <span class="variable">number</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">(List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="comment">//只能获取元素  返回Object类型  但无法对o进行强转  因为不知道List中的具体类型</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; integers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Float&gt; floats = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        fun1(integers);    </span><br><span class="line">        fun1(floats);     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我对方法fun1进行了重载，我认为的是List &lt; Integer&gt;和List &lt; Float&gt; 是两个不同的类型，所以构成重载。但是实际上它俩的类型是一样的（类型擦除），代码会发生编译错误。那怎么办呢？可不可以试一下继承？Integer和Float都是Number的子类，我定义一个List&lt; Number &gt; 行不行？结果是并不行。（具体为啥我也不是很清楚，后期再补充吧。）</p><p>但是我们学了泛型啊，可以使用泛型来解决吗？答案是可以的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ljb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李家宝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/7/30 15:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">(List&lt;T&gt; list)</span> &#123;</span><br><span class="line">        <span class="comment">//获取元素 返回实际类型</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//打印</span></span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; integers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Float&gt; floats = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        integers.add(<span class="number">20</span>);</span><br><span class="line">        floats.add(<span class="number">20.0f</span>);</span><br><span class="line">        fun1(integers);</span><br><span class="line">        fun1(floats);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是有没有想过，但是我们在fun1方法中根本没办法通过引用变量t（13行）来调用对象的一些成员方法。就比如下面的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ljb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李家宝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/7/30 15:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">(List&lt;T&gt; list)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取元素 返回实际类型</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//我想获取对象t的名字</span></span><br><span class="line">        System.out.println(t.getName());   <span class="comment">//这里编译报错</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        List&lt;Student&gt; students =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李家宝&quot;</span>));</span><br><span class="line">        fun1(students);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第17行会出现编译报错。那操作也太局限了，我总不能在fun1中把t强转成Student然后调用getName方法吧，因为它的实际类型是根据传过来的实参确定的，并不一定是Student类型啊！ 怎么办？ 其实这里可以利用反射机制进行操作。我们可以获取t的Class对象，然后反射它的成员方法并调用。代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ljb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李家宝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/7/30 15:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">(List&lt;T&gt; list)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取元素 返回实际类型</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">        Class&lt;?&gt; clazz = t.getClass();</span><br><span class="line">        <span class="comment">//反射成员方法getName</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">getName</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line">        <span class="comment">//将对象t传入反射方法</span></span><br><span class="line">        System.out.println(getName.invoke(t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        List&lt;Student&gt; students =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李家宝&quot;</span>));</span><br><span class="line">        fun1(students);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反射的内容有一篇笔记有介绍，这里不再多说。但是使用反射显然有点麻烦，最终还是要靠我们的通配符”?”来解决。</p><h4 id="通配符的使用"><a href="#通配符的使用" class="headerlink" title="通配符的使用"></a>通配符的使用</h4><blockquote><p>通配符 “ ? “ 是在为作为形参的泛型类指定泛型时使用。两者具体差别用代码展示</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ljb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李家宝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/7/30 15:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用通配符？ 通配符是实参类型   通配符就是用来接收所有类型对象  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">(List&lt;?&gt; list)</span> &#123;</span><br><span class="line">        <span class="comment">//只能获取元素  返回Object类型  但无法对o进行强转  因为不知道List中的具体类型 </span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用泛型T   泛型是形参类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">(List&lt;T&gt; list, T str)</span> &#123;</span><br><span class="line">        <span class="comment">//可以返回Object 也可以返回T</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//可以强转，因为知道是类型T</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">t2</span> <span class="operator">=</span> (T) object;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//也可以返回T   而通配符并不能返回&#x27;?&#x27;</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//还能添加元素</span></span><br><span class="line">        list.add(str);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; str = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        str.add(<span class="string">&quot;ljb&quot;</span>);</span><br><span class="line">        fun1(str);</span><br><span class="line">        fun2(str, <span class="string">&quot;nb&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在单独使用类型通配符或者泛型时，两者的区别不大。<strong>通配符刚开始那里有提出过一个需求，那个需求也能通过通配符解决</strong>。但是泛型可以支持添加元素，通配符不行。说白了，通配符就是能够接受所有类型。</p><blockquote><p>说明一下上面的代码14所谓的不能强转，我的意思是，在fun1方法中，并不知道o的具体类型，所以无法强转为o的具体类型。但是不代表我不能在里面这样写  <strong>String str=(String) o;</strong> 因为我显然知道传进去的是String类型，这样写肯定没问题，能用运行成功。</p><p>并且对于fun2而言，我知道o就是T类型，所以也没有必要用<strong>Object</strong> <strong>object = list.get(0);</strong>  直接就用<strong>T t = list.get(0);</strong>就行</p></blockquote><h4 id="通配上下限"><a href="#通配上下限" class="headerlink" title="通配上下限"></a>通配上下限</h4><blockquote><p>乍一看，感觉通配符还不如泛型好用啊？但是jdk为通配符提供了定义通配上限和下限的操作，让操作变得更灵活了。</p></blockquote><h5 id="通配上限"><a href="#通配上限" class="headerlink" title="通配上限"></a>通配上限</h5><blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">List&lt;? extends Aniaml&gt; list    //假设有这个关系   MinCat extends Cat extends Aniaml</span></span><br><span class="line"><span class="comment">当形参定义为上述类型时，可以传入List&lt;Aniaml及Aniaml子类&gt;，但是仍然无法进行添加操作，你想一下，方法中只能确定传过来的集合元素类型范围是Aniaml及其子类，我要如果我要添加一个Cat类型的元素，可能集合元素类型是MinCat，那么必然报错啊（你可以写MinCat minCat = (MinCat) new Cat(); 虽然编译不报错，但运行就报错了），就多态的知识。</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="通配下限"><a href="#通配下限" class="headerlink" title="通配下限"></a>通配下限</h5><blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">List&lt;? super MinCat&gt; list      </span></span><br><span class="line"><span class="comment">当形参定义为上述类型时，可以传入List&lt;MinCat及MinCat父类&gt;，可以进行添加元素操作，但只能添加MinCat及MinCat子类类型的元素。你想一下，不管List的元素是什么类型，至少是MinCat或MinCat的父类，根据多态，子类可以转换成父类</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li><p>通配符更像是一个正则表达式符号，可以匹配所有的类型，并不能作为一种类型进行变量或方法返回值的声明。</p></li><li><p>而泛型就一种真正的类型，可以声明为变量和方法返回值的类型。只不过它的实际类型是要根据传过来的参数实际类型进行确定。</p></li></ul><h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p>看下面的代码，输出都是ArrayList类型型，输出结果为真。这与泛型是String还是Integer无关。</p><p><img src="/pic/泛型/image-20230804081153365.png" alt="image-20230804081153365"></p><p><img src="/pic/泛型/image-20230804081051599.png" alt="image-20230804081051599"></p><p><img src="/pic/泛型/image-20230804081714497.png" alt="image-20230804081714497"></p><p><img src="/pic/泛型/image-20230804081832106.png" alt="image-20230804081832106"></p><p>类型擦除在编译阶段完成</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><blockquote><p>时间：2023/8/4 16:00</p><p>学习红黑树时遇到下面这种写法 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">RBNode</span>&lt;K <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;K&gt;,V&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是一个静态内部类（不重要），整体的一个形式和我们之前定义泛型类时是一致的，就是声明一个泛型列表    &lt; K, V,T … &gt; 然后在类内部就能用这样字母声明变量和方法。只不过这里它给其中的泛型K做了一个约束，就是必须是Comparable接口的子类。</p><p>这里很奇怪，明明Comparable是一个接口，为什么用extends？ 语法就是这样，没有为什么。这就是Java提供了一种语法来限制泛型的可实现类。它的语法规则就是下面这样</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T <span class="keyword">extends</span> <span class="title class_">anyClass</span>&gt;   <span class="comment">//这里的anyClass可以是接口，也可以是类。反正T必须实现或者继承anyClass</span></span><br></pre></td></tr></table></figure><p>这可不要瞎用，不要与  通配符的上限写法搞混了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">(List&lt;? extends Aniaml&gt;)</span>;   <span class="comment">//通配符这样用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">(List&lt;T extends Animal&gt;)</span>;   <span class="comment">//下面这个不可以这样乱搞   错误！！！！！！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//仿照用在类上时的写法</span></span><br><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Animal</span>&gt; <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">(List&lt;T&gt;)</span>;  <span class="comment">//传给fun2的list列表的的元素就必须继承Animal类，否则编译报错</span></span><br></pre></td></tr></table></figure><p>时间：2023/8/4 19:00</p><p>静态方法中不能使用类定义时的泛型</p><p><img src="/pic/泛型/image-20230804191539781.png" alt="image-20230804191539781"></p><p>网上的解答：因为静态方法属于类的信息，而不是实例对象的信息。静态方法的加载先于类的实例化，也就是说类中的泛型还没有传递真正的类型参数，静态的方法就已经加载完成了（方法的参数类型，返回值类型啥的都需要提前确定好）。所以静态方法不能使用泛型</p><p>对于网上的解答还是没让我弄明白，泛型不是在编译期就被擦除了吗，不是都为Object类型了吗？那类上面为啥就能使用泛型了？类不是也得先加载吗？还有静态方法为什么又可以定义为泛型方法。对于这些可能还得再看看JVM的知识。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于静态变量、内部类的详细说明</title>
      <link href="/posts/35853/"/>
      <url>/posts/35853/</url>
      
        <content type="html"><![CDATA[<h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><blockquote><p>静态变量只能定义在方法之外、类中。静态方法、成员方法、main方法中都不能定义静态变量。但是可以被以上三个方法访问。</p></blockquote><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><h3 id="四不"><a href="#四不" class="headerlink" title="四不"></a>四不</h3><ul><li>不能定义静态变量       （方法的共同点）</li><li>不能定义静态内部类   （方法的共同点）</li><li>不能访问非静态变量   （成员变量）</li><li>不能调用非静态方法   （成员方法）</li></ul><h3 id="四能-（上面四条逆否）"><a href="#四能-（上面四条逆否）" class="headerlink" title="四能 （上面四条逆否）"></a>四能 （上面四条逆否）</h3><ul><li>能定义非静态内部类   理解为可以在静态方法中定义局部内部类</li><li>…</li></ul><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><h3 id="二不"><a href="#二不" class="headerlink" title="二不"></a>二不</h3><ul><li>不能定义静态变量</li><li>不能定义静态内部类</li></ul><h3 id="五能"><a href="#五能" class="headerlink" title="五能"></a>五能</h3><ul><li>能访问静态变量</li><li>能调用静态方法</li><li>能访问成员变量</li><li>能调用成员方法</li><li>能定义局部内部类</li></ul><h2 id="静态方法和成员方法总结"><a href="#静态方法和成员方法总结" class="headerlink" title="静态方法和成员方法总结"></a>静态方法和成员方法总结</h2><ul><li>不管是静态方法还是成员方法中，都不能定义static修饰的变量、类。也即静态变量和静态内部类</li><li>不管是静态方法还是成员方法中，都可以出现局部内部类。</li></ul><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><blockquote><p>局部内部类就和方法中的局部变量一样，作用范围是方法内，无法在外边访问，随方法调用的结束而消亡。别妄想将局部内部类作为返回值返回。</p></blockquote><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><blockquote><p>和成员变量很类似，只不过它是一个类，不是一个变量。成员变量、成员方法这些都属于类的实例对象，成员内部类也不例外。在本类中，也不允许静态方法创建成员内部类对象</p></blockquote><h3 id="访问方式（创建对象）"><a href="#访问方式（创建对象）" class="headerlink" title="访问方式（创建对象）"></a>访问方式（创建对象）</h3><h4 id="其他类中访问"><a href="#其他类中访问" class="headerlink" title="其他类中访问"></a>其他类中访问</h4><blockquote><p>直接先new一个外部类实例，在通过外部类实例new内部类。</p><p>Outer outer = new Outer();</p><p>Outer.Inner inner1 = outer.new Inner();</p><p>或者写成一行</p><p>Outer.Inner inner = new Outer().new Inner();</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ljb;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李家宝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/8/3 20:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String age=<span class="string">&quot;20&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ljb;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李家宝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/7/30 15:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * new的时候 成员内部类不属于类的消息，属于实例</span></span><br><span class="line"><span class="comment">         * 所以要先new 实例 然后拿着实例new内部类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        <span class="comment">//或者下面这样</span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">inner1</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line"></span><br><span class="line">        System.out.println(inner.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在本类中访问"><a href="#在本类中访问" class="headerlink" title="在本类中访问"></a>在本类中访问</h4><blockquote><p>注意，由于成员内部类和成员变量类似的，静态方法不能访问成员变量，所以静态方法也不能访问成员内部类（创建成员内部类对象）。本类中访问则只能在成员方法中访问 直接new 对象就行</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ljb;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李家宝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/8/3 20:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String age=<span class="string">&quot;20&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    <span class="comment">//成员内部类只能在成员方法内部访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        System.out.println(inner.age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><blockquote><p>静态内部类和静态变量一样，只能定义在方法外，类中，属于类的属性。</p></blockquote><h3 id="访问方式（创建对象）-1"><a href="#访问方式（创建对象）-1" class="headerlink" title="访问方式（创建对象）"></a>访问方式（创建对象）</h3><h4 id="其他类中访问-1"><a href="#其他类中访问-1" class="headerlink" title="其他类中访问"></a>其他类中访问</h4><blockquote><p>必须通过  外部类类名.静态内部类类名 new 外部类类名.静态内部类类名();  Outer.Inner inner = new Outer.Inner();</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ljb;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李家宝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/8/3 20:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String age=<span class="string">&quot;20&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ljb;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李家宝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/7/30 15:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * new的时候 通过类名.静态内部类类名</span></span><br><span class="line"><span class="comment">         * 不能直接new Inner  也不能先new一个Outer对象再通过实例变量访问</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.Inner();</span><br><span class="line">        System.out.println(inner.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在本类中访问-1"><a href="#在本类中访问-1" class="headerlink" title="在本类中访问"></a>在本类中访问</h4><blockquote><p>直接  new 对象就行  Inner inner = new Inner();</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ljb;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李家宝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/8/3 20:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String age=<span class="string">&quot;20&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在本类中访问直接new</span></span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        System.out.println(inner.age);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//成员方法能访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        System.out.println(inner.age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态方法也能访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        System.out.println(inner.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法笔记</title>
      <link href="/posts/28038/"/>
      <url>/posts/28038/</url>
      
        <content type="html"><![CDATA[<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="思路：（升序）"><a href="#思路：（升序）" class="headerlink" title="思路：（升序）"></a>思路：（升序）</h4><ul><li>快速排序使用递归的思想，先在原数组中找一个基准值（要用一个变量保存起来），一般是第一个或者最后一个元素。（可以减少交换次数）</li><li>使用两个指针（普通变量i,j即可）分别指向第一个和最后一个元素。</li><li>如果选择第一个元素作为基准值，那么就从右边开始扫描，比较右指针指向的数与基准值的大小，如果小于基准值，那么将右指针指向的值赋给左指针（A[i]=A[j]，不用担心A[i]原来的值被覆盖，因为最开始左指针指向基准值，且用变量保存了。那右指针A[j]不需要变吗？不需要！按理说是要把基准值赋给A[j]，但是没有必要）然后左指针就右移动一位，并开始比较左指针与基准值的大小关系，如果大于基准值，就将左指针的值赋给右指针（A[j]=A[i]），然后右指针左移一位。重复操作，直到i=j，而i，j的值就是最终基准值的位置</li><li>在扫描的过程中也就是移动指针时，左指针右移要找比基准值大的数，没找到就一直右移。右指针左移要找比基准值小的数，没找到就一直左移。最终就是要让小于基准值的数在左边，大于基准值的数在右边。</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> A       待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left    起始位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right   结束位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> position;       <span class="comment">//记录基准值所在下标</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        position = partition(A, left, right);</span><br><span class="line">        quickSort(A, left, position);</span><br><span class="line">        quickSort(A, position + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对子数组进行排序 最终返回基准值所在下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> A</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left, j = right;</span><br><span class="line">    <span class="type">int</span> <span class="variable">basic</span> <span class="operator">=</span> A[i];     <span class="comment">//数组的最左边元素为基准值  基准值不参与交换</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; i &amp;&amp; A[j] &gt;= basic) &#123;  <span class="comment">//取最左边元素为基准值 那么就从最右边开始扫描 找出右边比基准值小的元素</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; i) &#123;</span><br><span class="line">            A[i] = A[j];  <span class="comment">//交换 但只需把找到的元素赋给左边  因为左边的值用basic变量记录了</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; A[i] &lt;= basic) &#123;     <span class="comment">//然后就要从左边找比基准值大的元素</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            A[j] = A[i];             <span class="comment">//也是只需要将找的的元素赋值给右边</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt; j);</span><br><span class="line">    A[i] = basic;      <span class="comment">//基准值最终的位置</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><blockquote><p>平均时间复杂度$O(n)=nlbn$</p><p>最差时间复杂度$O(n)=n^2$</p></blockquote><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><blockquote><p><strong>堆：用完全二叉树解释如下</strong></p><ul><li><strong>大根堆：根节点大于孩子节点  </strong></li><li><strong>小根堆：根节点小于孩子节点</strong></li></ul><p><strong>大根堆最顶部节点一定是最大的，小根堆最顶部节点一定是最小的。其他节点间的大小关系是不确定的</strong>。</p></blockquote><h4 id="思路：（大根堆）"><a href="#思路：（大根堆）" class="headerlink" title="思路：（大根堆）"></a>思路：（大根堆）</h4><ul><li><strong>初建堆</strong>  首先有一个初建堆的过程，将无序数组化为大根堆。先从最后一个<strong><em><u>根节点</u></em></strong>开始（完全二叉树结构中最后一个根节点的序号是$n/2$,向下取整，比如5个节点的完全二叉树，最后一个根节点的序号是2），调整根节点形成的子树。主要过程就是先看该根节点是否有左孩子（这个判断是个循环条件，刚开始进入循环，由于根节点是整个完全二叉树的最后一个根节点，肯定是有做孩子的，但在循环中，根节点会更新），如果有，再判断是否有右孩子，如果也有，那就比较一下左右孩子的大小，选出最大的与根节点进行交换。然后，将进行交换的孩子节点序号作为新的根节点，继续往下交换。当一趟交换完成后，从<strong><em><u>倒数第二个根节点</u></em></strong>开始重相同操作。直到所有根节点都完成交换。一次初建堆操作包含对<strong><em><u>所有根节点</u></em></strong>的处理，并会把最大值交换到最顶部位置。</li><li><strong>重建堆</strong>  由于初建堆操作把最大值交换到最顶部，所以可以把最大值与最后面部分的节点交换位置，并进行堆的重建，重建时，将第1至第n-1个数作为新的完全二叉树，最后一个数相当于已经排好序了。<strong><em><u>第x次建立堆后，将最大值与倒数第x个数进行交换，并将1至n-x节点看成新的二叉树。</u></em></strong>每次重建堆<strong><em><u>不再是从最后一个根节点开始操作</u></em></strong>，而是<strong><em><u>从第一个根节点</u></em></strong>开始，初建堆操作已经将根节点与孩子节点的大小关系处理好了，现在只不过是第一个根节点的值发生了变化，从第一个根节点一直往下交换即可，交换完成新的最大值又被交换到了最顶部，然后与倒数节点进行交换，重复执行，最后完成排序。</li></ul><h4 id="堆排序与选择排序"><a href="#堆排序与选择排序" class="headerlink" title="堆排序与选择排序"></a>堆排序与选择排序</h4><blockquote><p>其实堆排序可以看成是选择排序的改进，每次找出最大值放入已排好序的部分。</p></blockquote><ul><li><p>选择排序：每次选出最大值放入已排好序部分后，再对剩余部分全部进行比较，而剩余部分仍然是一个无序的数组 需要比较n-x-1次</p></li><li><p>堆排序：在初建堆时，根节点与孩子节点的大小关系已经确定。每次重建时，比较一下左右孩子的大小，然后将根节点与较大的孩子进行交换，每比较一次，就减少了一半的比较操操作，平均比较次数是二叉树的高度-1，是lbn级别。</p></li></ul><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初建堆  需要对所有根节点进行调整</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> A</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createHeap</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> k;    <span class="comment">//指向需要调整的根节点</span></span><br><span class="line">    <span class="keyword">for</span> (k = n / <span class="number">2</span>; k &gt;= <span class="number">1</span>; k--) &#123;</span><br><span class="line">        swift(A, k, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进行堆的调整</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> A 待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k 调节范围起点   始终指向根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 调整范围终点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swift</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">2</span> * k;</span><br><span class="line">    <span class="keyword">while</span> (p &lt;= n) &#123;     <span class="comment">//只有当k有左孩子时才需要调整</span></span><br><span class="line">        t = p;           <span class="comment">//t先指向左孩子   </span></span><br><span class="line">        <span class="keyword">if</span> (p &lt; n) &#123;     <span class="comment">//如果k有右孩子  需要比较左右孩子的大小</span></span><br><span class="line">            <span class="keyword">if</span> (A[p] &lt; A[p + <span class="number">1</span>]) &#123;    <span class="comment">//如果右孩子大 则需要将t指向右孩子</span></span><br><span class="line">                t = p + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (A[k] &lt; A[t]) &#123;     <span class="comment">//比较根节点与孩子的大小   如果根节点小于孩子节点   则需要交换</span></span><br><span class="line">            temp = A[k];</span><br><span class="line">            A[k] = A[t];</span><br><span class="line">            A[t] = temp;</span><br><span class="line">            k = t;            <span class="comment">//k指向新的根节点</span></span><br><span class="line">            p = <span class="number">2</span> * k;        <span class="comment">//p指向新的根节点的左孩子</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;              <span class="comment">//根节点大于孩子  则已经是大根堆 不必调整  结束</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> A</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    createHeap(A, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &gt; <span class="number">0</span>; i--) &#123;    <span class="comment">//调整堆</span></span><br><span class="line">        A[<span class="number">0</span>] = A[n - <span class="number">1</span>];            <span class="comment">//无序数组要求第一个位置A[0]不存数，便于代码书写与理解</span></span><br><span class="line">        A[n - <span class="number">1</span>] = A[<span class="number">1</span>];</span><br><span class="line">        A[<span class="number">1</span>] = A[<span class="number">0</span>];</span><br><span class="line">        swift(A, <span class="number">1</span>, i - <span class="number">1</span>);    <span class="comment">//只需要</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><blockquote><p>平均时间复杂度$O(n)=nlbn$</p><p>最差时间复杂度$O(n)=nlbn$</p><h5 id="简单分析一下："><a href="#简单分析一下：" class="headerlink" title="简单分析一下："></a>简单分析一下：</h5><p>初建堆要对$n/2$ 个根节点进行调整，每个根节点调整次数（孩子节点的比较次数）平均也就是高度的一半 $\frac{1}{2}lbn$（如果加上根节点与孩子节点的比较差不多就是$lbn$）,   所以初建堆差不多也就是$\frac{1}{4}lbn$  ,调整堆也是类似，相加还是 $nlbn$  级别     （这些数据只是个大概，影响的是系数大小，不会对n哟影响）</p></blockquote><h5 id=""><a href="#" class="headerlink" title=" "></a> </h5><h3 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h3><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><ul><li>合并数组  循环合并，先按照两个子数组的长度为1、2、4、8…进行第合并,每一轮合并都包含多次合并操作。就比如进行长度为8的合并时，就要对{0-7}和{8-15}进行合并 ，对{16-23}和{24-31}进行合并……。</li><li>合并其实就是依次比较两个子数组中的元素大小，将它们另一个临时数组保存，最后把临时数组的内容复制到原数组对应下标。</li></ul><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 划分长度进行合并</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> A   原数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n   数组长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> n)</span> &#123;     <span class="comment">//进行归并</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i = i * <span class="number">2</span>) &#123;     <span class="comment">//依次归并长度为1,2,4,8...的数组</span></span><br><span class="line">        mergePass(A, i, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> A        原数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length   子数组长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n        原数组长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergePass</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> length, <span class="type">int</span> n)</span> &#123;   <span class="comment">//合并长度为length的数组</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i + <span class="number">2</span> * length - <span class="number">1</span> &lt; n; i = i + <span class="number">2</span> * length) &#123;</span><br><span class="line">        merge(A, i, i + length - <span class="number">1</span>, i + <span class="number">2</span> * length - <span class="number">1</span>);   <span class="comment">//下界是i  长度是length 所以mid=i+length-1 上界是mid+length-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i + length - <span class="number">1</span> &lt; n - <span class="number">1</span>) &#123;  <span class="comment">//分界点未超过数组最大下标 也就是但大于一个 小于两个，还是要合并一次</span></span><br><span class="line">        merge(A, i, i + length - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> A</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left    上界  left-mid确定第一个子数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mid     第一个子数组末尾</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> high    下界  mid+1-high确定第二个子数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[high - left + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left, j = mid + <span class="number">1</span>, p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &gt; A[j]) &#123;</span><br><span class="line">            temp[p++] = A[j++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[p++] = A[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        temp[p++] = A[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">        temp[p++] = A[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = left, p = <span class="number">0</span>; i &lt;= high; i++, p++) &#123;</span><br><span class="line">        A[i] = temp[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于代码中的几个细节此处记录以下，老是容易忘记</p><blockquote><p>下界  ：$i$     最初是0</p><p>分界  ：$i+length-1$</p><p>上界  ：$i+2*length-1$</p><p>循环条件  ：上界不超过数组最大下标   $i+2*length-1&lt;n-1$</p><p>循环变量变化  ：上一组被合并的数组的上界加1   $i+2*length-1+1$</p><p>剩余数组大于1个小于两个 ：分界小于最大下标    $i+length-1&lt;n-1$</p><p>第一个函数，是先划分合并的两两子数组长度length，每次都是都整个数组进行合并。</p><p>第二个函数，拿到了子数组长度后，就从0开始，计算相邻两个数组的上下边界（两个数组合在一起的上下界，不是各自的上下界），并传入第三个函数进行合并。第三个函数需要知道被合并的相邻的两个数组的上下界以及二者间的分界。因此第二个函数的循环，以  $i=0$  为下界，i加上两个length长度再减去1 即   <strong>$i+2*length-1$</strong>    计算出上界，而分界就是i加上一个length再减去1即$i+length-1$。循环变量的变化显然就是变为下一组需要被合并的两个数组的下界，也就是上一组被合并的数组的下界加1，即 $i+2*length$。循环条件的判断就是判断被合并的数组的上界是否没有超出原数组的大小。最后要进行一次合并，因为上界如果不满足循环条件，有多种情况，可能就剩一个length长度的数组，或者不足一个，也或者大于一个小于两个，对于最后者这种情况也就是分界点没超过数组长度$i+length-1&lt;n-1$，就需要再次进行合并，那么最后这一次合并的上下界就是 i，n-1。</p></blockquote><h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><blockquote><p>平均时间复杂度$O(n)=nlbn$</p><p>最差时间复杂度$O(n)=nlbn$</p><p>简单分析一下</p><p>合并过程中，因为是对整个数组进行合并，不管是合并子数组的长度为多少，比较次数的规模基本就是n，因为比较的时候本来就是两个数组中的元素取出来依次比较大小，就算运气最好情况也是将另一个数组直接拼接到另一个后面，整体下来还是  <em>$\frac{n}{2}$</em>  。如果数组元素的个数 $n=2^k$  长度划分就有k种 所以 最终时间复杂度就是    $k*n,k=lbn$   所以最终是   $nlbn$       </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法分析与设计基础第3版</title>
      <link href="/posts/35662/"/>
      <url>/posts/35662/</url>
      
        <content type="html"><![CDATA[<h1 id="算法分析与设计基础第3版"><a href="#算法分析与设计基础第3版" class="headerlink" title="算法分析与设计基础第3版"></a>算法分析与设计基础第3版</h1> <embed src="/pdf/算法分析与设计基础3.pdf" width="100%" height="750" type="application/pdf"> ]]></content>
      
      
      <categories>
          
          <category> book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法设计与分析基础笔记</title>
      <link href="/posts/18798/"/>
      <url>/posts/18798/</url>
      
        <content type="html"><![CDATA[<h4 id="递归算法数序分析"><a href="#递归算法数序分析" class="headerlink" title="递归算法数序分析"></a>递归算法数序分析</h4><p>在计算一些常用算法的时间复杂度时，经常涉及到递归，因此也就离不开递归算法的分析</p><h4 id="先看一个例子"><a href="#先看一个例子" class="headerlink" title="先看一个例子"></a>先看一个例子</h4><p>计算函数的时间复杂度</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n*f(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面函数的基本操作就是做乘法，所以计算函数的时间复杂度，其实就是计算<strong>乘法的操作次数。</strong></p><p>假设M(n)代表传入参数n时，函数进行乘法操作的次数，所以有</p><script type="math/tex; mode=display">M(n)= \begin{cases}0\quad\textcolor{orange}{n=0};  \\M(n-1)+1\quad\textcolor{orange}{n>0};\\\end{cases}</script><p>其中加1是指将n乘以f(n-1)。所以根据上面的公式得</p><script type="math/tex; mode=display">\begin{aligned}M(n)&=M(n-1)+1\\&=M(n-2)+1+1\\  &=M(n-3)+1+1+1\\&=M(n-4)+1+1+1+1\\&=···\\&=M(0)+n\\&=n \\  \end{aligned}</script><p>$\begin{aligned}<br> 时间复杂度    \textcolor{red}{O(n)=n}<br>\end{aligned} $</p><h5 id="进行递归算法分析的主要步骤"><a href="#进行递归算法分析的主要步骤" class="headerlink" title="进行递归算法分析的主要步骤"></a>进行递归算法分析的主要步骤</h5><ul><li>确定输入参数的规模</li><li>找出基本操作</li><li>分析相同规模不同输入的算法的最优、最差、平均效率差别</li><li>建立递推关系</li><li>解递推式</li></ul><h4 id="汉诺塔递归算法分析"><a href="#汉诺塔递归算法分析" class="headerlink" title="汉诺塔递归算法分析"></a>汉诺塔递归算法分析</h4><blockquote><p>汉诺塔游戏是将n个盘子通过一个中间柱子，移动到第三个柱子，规则就是小盘子必须在大盘子上面。</p><p><img src="/pic/算法笔记/image-20230801112714469.png" alt="image-20230801112714469"></p><p>问题可以分解成三步，先将上面的n-1个盘子移动到第二根柱子，然后把最大的盘子移动到第三根柱子，最后把n-1个盘子移动到第三根柱子。假设$M(n)$表示将n个盘子移动到第三根柱子需要的步骤数，所以有以下递推式</p><script type="math/tex; mode=display">\begin{aligned} &M(n)=M(n-1)+1+M(n-1) \\&M(n)=2M(n-1)+1\\\\&M(n)= \begin{cases}1\quad\textcolor{orange}{n=1};  \\\\2M(n-1)+1\quad\textcolor{orange}{n>0};\\\end{cases}\end{aligned}</script><p>所以有</p><script type="math/tex; mode=display">\begin{aligned} \textcolor{green}{M(n)}&=2M(n-1)+1\\&=2^2M(n-2)+1+2^1\\&=2^3M(n-3)+1+2^1+2^2\\&=2^4M(n-4)+1+2^1+2^2+2^3\\&=···\\&=2^{n-1}M(1)+1+2+2^2+2^3+···2^{n-2}\\&=2^{n-1}+\frac{1-2^{n-1}}{1-2}\\&=2^{n-1}+2^{n-1}-1\\&=\textcolor{red}{2^n-1}\\\\时间复杂度：\textcolor{red}{O(n)=2^n}\end{aligned}</script></blockquote><h4 id="再看一个例子"><a href="#再看一个例子" class="headerlink" title="再看一个例子"></a>再看一个例子</h4><p>计算时间复杂度</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f(n/<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>这种类型的不能用反向替换方法，如果像 <script type="math/tex">M(n)=M(\frac{n}{2})+1 \\\space\space M(\frac{n}{2})=M(\frac{n}{4})+1</script>  这样替换下去，n不是2的乘方的话，终止不了的。只能在n为2的k次方的情况下求解递推式，所以假设 $n=2^k$ </p></blockquote><p>上公式</p><script type="math/tex; mode=display">\begin{aligned}&令 n=2^k  \\{\space\space}&M(n)=M(\frac{n}{2})+1  \\&=>M(2^k)=M(2^{k-1})+1  \\&M(1)=0\\\end{aligned}\begin{aligned} M(2^k)&=M(2^{k-1})+1 \\&=M(2^{k-2})+1+1\\&=M(2^{k-3})+1+1+1\\&=···\\&=M(2^{k-k})+1+1+···+1+1+1\\&=M(1)+k\\&=\textcolor{red}{k}\\2^k=n {\space\space}即{\space\space}k=log_2n{\space\space} 所以M(n)=log_2n\\时间复杂度：\textcolor{red}{O(n)=log_2n}\end{aligned}</script><p>其他的$\frac{n}{3},\frac{n}{4}$都是一样的道理</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法设计与分析基础笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>project</title>
      <link href="/posts/3210/"/>
      <url>/posts/3210/</url>
      
        <content type="html"><![CDATA[<h4 id="课程预览"><a href="#课程预览" class="headerlink" title="课程预览"></a>课程预览</h4><p><img src="/pic/xuecheng/image-20230731165620030.png" alt="image-20230731165620030"></p><ol><li>前端通过通过点击课程的预览按钮，进入预览页面。前端传递课程id,访问内容管理服务的CoursePublishController,根据课程id，将课程的师资信息，营销信息、基本信息、课程计划信息查询并组装。</li><li>组装后的信息通过freemarker模版引擎将数据渲染到course_template.ftl上，然后返回给前端。</li><li>进入预览页面，查看视频，会发送两次请求，先根据课程id到内容管理服务的CourseOpenController查询课程信息，这里调用的查询方法和第一步一样（没必要差这么全吧）。第二次将课程计划绑定的媒资id发送媒资管理服务的MediaOpenController，查询媒资的访问url，返回前端，以便播放。</li></ol><h4 id="课程提交审核"><a href="#课程提交审核" class="headerlink" title="课程提交审核"></a>课程提交审核</h4><ol><li><p>为实现审核过程中可以修改，设计了课程预发布表，机构人员可以随意修改课程计划、课程基本信息等。提交时，将这些信息组合起来存入预发布表。审核人员审核预发布表中的内容，审核中时，要把预发布表中的审核状态设置为审核中。</p></li><li><p>点击提交审核课程，传递课程id，访问CoursePublishController的方法，将课程的各种信息组装起来存入课程预发布表。存入课程预发布表时要先判断课程信息是否完备，完备后，查询预发布表中信息，看是否存在了，若存在，要看课程的审核状态，如果是审核中，则不可再提交，否则，对存在的信息进行更新操作，不存在就直接插入。然后修改课程基本信息表中的状态为审核中</p></li><li><p>由于进行了预发布表的插入和课程基本信息表的修改，要加上事务控制。</p><p>课程有两个状态一个审核状态{添加课程成功未提交审核   状态为“已提交”，提交审核了  “已提交”，审核通过了  “审核通过”，审核不通过 “审核不通过”}  一个发布状态{目前不清楚}        课程预发布表中有一个审核状态 {提交审核存进来的，初始都为 “已提交”，其他类似，只是没有未提交这个状态}</p></li></ol><h4 id="课程发布"><a href="#课程发布" class="headerlink" title="课程发布"></a>课程发布</h4><h5 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h5><blockquote><p>分布式系统把一个应用系统拆分成分多个可独立部署的微服务，不同微服务间通过网络远程协作（调用）完成的事务操作就是分布式事务。</p><p><strong><em><u>注</u></em></strong></p><p>我之前一直以为只要是连的同一个主机的mysql，@Transaction就能控制事务。只要操作了不同的数据库（这个是指mysql中创建的database，不是指mysql本身，mysql属于数据库管理系统层面）就是分布式事务。<strong><em><u>但注意</u></em></strong>，如果是两个微服务连接的同一个数据库，也属于分布式事务，原因就是跨JVM进程，两个微服务持有了不同的数据库链接进行数据库操作，此时产生分布式事务。</p></blockquote><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><ul><li><p>课程审核成功后，需要将预发布表中的信息复制到发布表。并把预发布表信息删掉</p></li><li><p>课程发布成功后，是可以被搜索到的，并且会有大量用户搜索。因此要把发布成功的信息存到  redis、es、minio。其中redis和es都是存课程信息，minio里面存渲染后的课程静态页面。</p></li><li><p>保存已发布课程的信息涉及到多个操作，涉及到分布式事务，用transaction是不行的。</p></li></ul><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><blockquote><p>首先要考虑是AP还是CP（CAP理论），此处只说保证AP也就是最终一致性的解决方法。</p></blockquote><p>使用XXL-Job+数据库表方案，当把发布的课程存入发布表后，再将课程存入消息表，（消息表与课程表在一个数据库中）此处是可以使用注解保证课程发布成功，消息表一定有数据。然后开启定时任务调度，将消息表中的数据取出依次完成存入redis、es、minio等操作，就算远程调用过程中出现问题，由于是定时调度，并且消息表中的数据还在，故可以保证最终一致性。</p><h5 id="消息SDK组件内容补充"><a href="#消息SDK组件内容补充" class="headerlink" title="消息SDK组件内容补充"></a>消息SDK组件内容补充</h5><blockquote><p>消息组件提供一套解决对消息的增删改查业务的方案，就是向外提供接口，但是不没有具体执行逻辑</p></blockquote><p>消息表中主要就是保存业务的主要信息。如该项目中保存的是课程的id，通过拿到消息表中的课程id，就能查询到课程信息，然后进行缓存操作。消息表中的业务字段有多个，用不上的给该字段存null就行。消息表中还有多个状态字段。因为要存到redis、es、minio，每个阶段完成后给对应字段标记，可以减少重复执行。</p><h4 id="补充关于XXL-Job使用分布式锁防止重复执行方案"><a href="#补充关于XXL-Job使用分布式锁防止重复执行方案" class="headerlink" title="补充关于XXL-Job使用分布式锁防止重复执行方案"></a>补充关于XXL-Job使用分布式锁防止重复执行方案</h4><blockquote><p>xxl-job调度进行视频转码时，用了乐观锁的方案进行避免重复执行，因为视频转码比较消耗CPU，因此应该尽量避免重复执行，而对于缓存操作，不是特别消耗CPU（视频中老师说的）</p></blockquote><h5 id="使用xxl-job时，不是配置了调度策略嘛，为什么还要用乐观锁？"><a href="#使用xxl-job时，不是配置了调度策略嘛，为什么还要用乐观锁？" class="headerlink" title="使用xxl-job时，不是配置了调度策略嘛，为什么还要用乐观锁？"></a>使用xxl-job时，不是配置了调度策略嘛，为什么还要用乐观锁？</h5><p>老师是这样解释的，当执行器与调度器之间的连接发生了中断，xxl-job就检测不到这个执行器了，虽然是发生了中断，但是执行器可能在执行任务了（执行任务时，连接中断了）。由于xxl-job是动态扩容，因此会对其他执行器进行重新排序（代码每个执行器就是根据自己的序号进行对应任务的处理），那么就导致其他执行器会调度执行（在断开连接的执行器执行完任务，删除任务表中数据之前）任务表中的任务，就有可能重复执行。</p><h4 id="页面静态化"><a href="#页面静态化" class="headerlink" title="页面静态化"></a>页面静态化</h4><blockquote><p>对于课程预览页面，用户搜索到就能查看，如果每次都访问tomcat服务器查询数据渲染返回，会使服务器压力过大，因此需要对课程预览页进行静态化并存储到minio。</p></blockquote><p>因为课程页面的静态化属于内容管理服务，而静态页面上传到minio属于文件服务，生成的静态页面在内存中，并没有在数据库存，不能通过发两次请求来实现。因此要进行远程调用。</p><p>内容管理服务调用媒资服务，那么就要在内容管理服务编写Feign接口，编写规则就是将媒资相关controller接口方法copy过来，写到feign接口中，接口要通过注解指定媒资服务的名称，启动类要加上开启远程调用注解，</p><h4 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h4><p>熔断降级的相同点都是为了解决微服务系统崩溃的问题，但它们是两个不同的技术手段，两者又存在联系。</p><p>熔断：</p><p>当下游服务异常而断开与上游服务的交互，它就相当于保险丝，下游服务异常触发了熔断，从而保证上游服务不受影响。</p><p>降级：</p><p>当下游服务异常触发熔断后，上游服务就不再去调用异常的微服务而是执行了降级处理逻辑，这个降级处理逻辑可以是本地一个单独的方法。</p><h4 id="存入索引库（ES）"><a href="#存入索引库（ES）" class="headerlink" title="存入索引库（ES）"></a>存入索引库（ES）</h4><p>存入索引库这不操作，可以在课程发布成功，插入到发布表的地方通过编写代码实现，但这样会让业务耦合。实现数据库与索引库同步有很多办法，包括使用  消息队列mq，XXL-Job定时调度、还有阿里Canal，它是通过解析mysql的一个日志文件，来判断数据库进行了哪些的操作，然后将这写操作同步到索引库。因为该项目从课程发布那一节之后，就选择的是用消息sdk来实现，也就是存入es、redis、上传minio都是从数据的消息表里面读，然后进行相应同步。</p><h4 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h4><p>之前的视频转码是用的是xxl-job，但没有用sdk组件，媒资数据库有个任务表，是从那个任务表里面拿到任务，然后进行转码处理。而在媒资之后，用到xxl-job的地方就是课程发布后，缓存的同步，有静态页面的上传，es的同步，redis的同步。</p>]]></content>
      
      
      
        <tags>
            
            <tag> xuecheng </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/posts/d87f7e0c/"/>
      <url>/posts/d87f7e0c/</url>
      
        <content type="html"><![CDATA[<h3 id="这是测试用例"><a href="#这是测试用例" class="headerlink" title="这是测试用例"></a>这是测试用例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;hello java&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="ReentrantLock和Synchronized的区别"><a href="#ReentrantLock和Synchronized的区别" class="headerlink" title="ReentrantLock和Synchronized的区别"></a>ReentrantLock和Synchronized的区别</h3><ul><li>ReentrantLock是一个类。synchronized是一个Java关键字</li><li>前者可重入 后者不可重入</li><li>前者获取锁失败可以返回  后者会阻塞</li><li>前者需要手动释放锁  后者自动释放锁</li></ul><h4 id="如何在4小时内睡满8小时"><a href="#如何在4小时内睡满8小时" class="headerlink" title="如何在4小时内睡满8小时"></a>如何在4小时内睡满8小时</h4><blockquote><p>这是一个智障问题</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156/"/>
      <url>/posts/4a17b156/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
