<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于静态变量、内部类的详细说明</title>
      <link href="/posts/35853/"/>
      <url>/posts/35853/</url>
      
        <content type="html"><![CDATA[<h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><blockquote><p>静态变量只能定义在方法之外、类中。静态方法、成员方法、main方法中都不能定义静态变量。但是可以被以上三个方法访问。</p></blockquote><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><h3 id="四不"><a href="#四不" class="headerlink" title="四不"></a>四不</h3><ul><li>不能定义静态变量       （方法的共同点）</li><li>不能定义静态内部类   （方法的共同点）</li><li>不能访问非静态变量   （成员变量）</li><li>不能调用非静态方法   （成员方法）</li></ul><h3 id="四能-（上面四条逆否）"><a href="#四能-（上面四条逆否）" class="headerlink" title="四能 （上面四条逆否）"></a>四能 （上面四条逆否）</h3><ul><li>能定义非静态内部类   理解为可以在静态方法中定义局部内部类</li><li>…</li></ul><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><h3 id="二不"><a href="#二不" class="headerlink" title="二不"></a>二不</h3><ul><li>不能定义静态变量</li><li>不能定义静态内部类</li></ul><h3 id="五能"><a href="#五能" class="headerlink" title="五能"></a>五能</h3><ul><li>能访问静态变量</li><li>能调用静态方法</li><li>能访问成员变量</li><li>能调用成员方法</li><li>能定义局部内部类</li></ul><h2 id="静态方法和成员方法总结"><a href="#静态方法和成员方法总结" class="headerlink" title="静态方法和成员方法总结"></a>静态方法和成员方法总结</h2><ul><li>不管是静态方法还是成员方法中，都不能定义static修饰的变量、类。也即静态变量和静态内部类</li><li>不管是静态方法还是成员方法中，都可以出现局部内部类。</li></ul><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><blockquote><p>局部内部类就和方法中的局部变量一样，作用范围是方法内，无法在外边访问，随方法调用的结束而消亡。别妄想将局部内部类作为返回值返回。</p></blockquote><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><blockquote><p>和成员变量很类似，只不过它是一个类，不是一个变量。成员变量、成员方法这些都属于类的实例对象，成员内部类也不例外。在本类中，也不允许静态方法创建成员内部类对象</p></blockquote><h3 id="访问方式（创建对象）"><a href="#访问方式（创建对象）" class="headerlink" title="访问方式（创建对象）"></a>访问方式（创建对象）</h3><h4 id="其他类中访问"><a href="#其他类中访问" class="headerlink" title="其他类中访问"></a>其他类中访问</h4><blockquote><p>直接先new一个外部类实例，在通过外部类实例new内部类。</p><p>Outer outer = new Outer();</p><p>Outer.Inner inner1 = outer.new Inner();</p><p>或者写成一行</p><p>Outer.Inner inner = new Outer().new Inner();</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ljb;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李家宝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/8/3 20:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String age=<span class="string">&quot;20&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ljb;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李家宝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/7/30 15:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * new的时候 成员内部类不属于类的消息，属于实例</span></span><br><span class="line"><span class="comment">         * 所以要先new 实例 然后拿着实例new内部类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        <span class="comment">//或者下面这样</span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">inner1</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line"></span><br><span class="line">        System.out.println(inner.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在本类中访问"><a href="#在本类中访问" class="headerlink" title="在本类中访问"></a>在本类中访问</h4><blockquote><p>注意，由于成员内部类和成员变量类似的，静态方法不能访问成员变量，所以静态方法也不能访问成员内部类（创建成员内部类对象）。本类中访问则只能在成员方法中访问 直接new 对象就行</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ljb;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李家宝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/8/3 20:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String age=<span class="string">&quot;20&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    <span class="comment">//成员内部类只能在成员方法内部访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        System.out.println(inner.age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><blockquote><p>静态内部类和静态变量一样，只能定义在方法外，类中，属于类的属性。</p></blockquote><h3 id="访问方式（创建对象）-1"><a href="#访问方式（创建对象）-1" class="headerlink" title="访问方式（创建对象）"></a>访问方式（创建对象）</h3><h4 id="其他类中访问-1"><a href="#其他类中访问-1" class="headerlink" title="其他类中访问"></a>其他类中访问</h4><blockquote><p>必须通过  外部类类名.静态内部类类名 new 外部类类名.静态内部类类名();  Outer.Inner inner = new Outer.Inner();</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ljb;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李家宝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/8/3 20:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String age=<span class="string">&quot;20&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ljb;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李家宝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/7/30 15:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * new的时候 通过类名.静态内部类类名</span></span><br><span class="line"><span class="comment">         * 不能直接new Inner  也不能先new一个Outer对象再通过实例变量访问</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.Inner();</span><br><span class="line">        System.out.println(inner.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在本类中访问-1"><a href="#在本类中访问-1" class="headerlink" title="在本类中访问"></a>在本类中访问</h4><blockquote><p>直接  new 对象就行  Inner inner = new Inner();</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ljb;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李家宝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/8/3 20:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String age=<span class="string">&quot;20&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在本类中访问直接new</span></span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        System.out.println(inner.age);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//成员方法能访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        System.out.println(inner.age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态方法也能访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        System.out.println(inner.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法笔记</title>
      <link href="/posts/28038/"/>
      <url>/posts/28038/</url>
      
        <content type="html"><![CDATA[<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="思路：（升序）"><a href="#思路：（升序）" class="headerlink" title="思路：（升序）"></a>思路：（升序）</h4><ul><li>快速排序使用递归的思想，先在原数组中找一个基准值（要用一个变量保存起来），一般是第一个或者最后一个元素。（可以减少交换次数）</li><li>使用两个指针（普通变量i,j即可）分别指向第一个和最后一个元素。</li><li>如果选择第一个元素作为基准值，那么就从右边开始扫描，比较右指针指向的数与基准值的大小，如果小于基准值，那么将右指针指向的值赋给左指针（A[i]=A[j]，不用担心A[i]原来的值被覆盖，因为最开始左指针指向基准值，且用变量保存了。那右指针A[j]不需要变吗？不需要！按理说是要把基准值赋给A[j]，但是没有必要）然后左指针就右移动一位，并开始比较左指针与基准值的大小关系，如果大于基准值，就将左指针的值赋给右指针（A[j]=A[i]），然后右指针左移一位。重复操作，直到i=j，而i，j的值就是最终基准值的位置</li><li>在扫描的过程中也就是移动指针时，左指针右移要找比基准值大的数，没找到就一直右移。右指针左移要找比基准值小的数，没找到就一直左移。最终就是要让小于基准值的数在左边，大于基准值的数在右边。</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> A       待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left    起始位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right   结束位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> position;       <span class="comment">//记录基准值所在下标</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        position = partition(A, left, right);</span><br><span class="line">        quickSort(A, left, position);</span><br><span class="line">        quickSort(A, position + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对子数组进行排序 最终返回基准值所在下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> A</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left, j = right;</span><br><span class="line">    <span class="type">int</span> <span class="variable">basic</span> <span class="operator">=</span> A[i];     <span class="comment">//数组的最左边元素为基准值  基准值不参与交换</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; i &amp;&amp; A[j] &gt;= basic) &#123;  <span class="comment">//取最左边元素为基准值 那么就从最右边开始扫描 找出右边比基准值小的元素</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; i) &#123;</span><br><span class="line">            A[i] = A[j];  <span class="comment">//交换 但只需把找到的元素赋给左边  因为左边的值用basic变量记录了</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; A[i] &lt;= basic) &#123;     <span class="comment">//然后就要从左边找比基准值大的元素</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            A[j] = A[i];             <span class="comment">//也是只需要将找的的元素赋值给右边</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt; j);</span><br><span class="line">    A[i] = basic;      <span class="comment">//基准值最终的位置</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><blockquote><p>平均时间复杂度$O(n)=nlbn$</p><p>最差时间复杂度$O(n)=n^2$</p></blockquote><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><blockquote><p><strong>堆：用完全二叉树解释如下</strong></p><ul><li><strong>大根堆：根节点大于孩子节点  </strong></li><li><strong>小根堆：根节点小于孩子节点</strong></li></ul><p><strong>大根堆最顶部节点一定是最大的，小根堆最顶部节点一定是最小的。其他节点间的大小关系是不确定的</strong>。</p></blockquote><h4 id="思路：（大根堆）"><a href="#思路：（大根堆）" class="headerlink" title="思路：（大根堆）"></a>思路：（大根堆）</h4><ul><li><strong>初建堆</strong>  首先有一个初建堆的过程，将无序数组化为大根堆。先从最后一个<strong><em><u>根节点</u></em></strong>开始（完全二叉树结构中最后一个根节点的序号是$n/2$,向下取整，比如5个节点的完全二叉树，最后一个根节点的序号是2），调整根节点形成的子树。主要过程就是先看该根节点是否有左孩子（这个判断是个循环条件，刚开始进入循环，由于根节点是整个完全二叉树的最后一个根节点，肯定是有做孩子的，但在循环中，根节点会更新），如果有，再判断是否有右孩子，如果也有，那就比较一下左右孩子的大小，选出最大的与根节点进行交换。然后，将进行交换的孩子节点序号作为新的根节点，继续往下交换。当一趟交换完成后，从<strong><em><u>倒数第二个根节点</u></em></strong>开始重相同操作。直到所有根节点都完成交换。一次初建堆操作包含对<strong><em><u>所有根节点</u></em></strong>的处理，并会把最大值交换到最顶部位置。</li><li><strong>重建堆</strong>  由于初建堆操作把最大值交换到最顶部，所以可以把最大值与最后面部分的节点交换位置，并进行堆的重建，重建时，将第1至第n-1个数作为新的完全二叉树，最后一个数相当于已经排好序了。<strong><em><u>第x次建立堆后，将最大值与倒数第x个数进行交换，并将1至n-x节点看成新的二叉树。</u></em></strong>每次重建堆<strong><em><u>不再是从最后一个根节点开始操作</u></em></strong>，而是<strong><em><u>从第一个根节点</u></em></strong>开始，初建堆操作已经将根节点与孩子节点的大小关系处理好了，现在只不过是第一个根节点的值发生了变化，从第一个根节点一直往下交换即可，交换完成新的最大值又被交换到了最顶部，然后与倒数节点进行交换，重复执行，最后完成排序。</li></ul><h4 id="堆排序与选择排序"><a href="#堆排序与选择排序" class="headerlink" title="堆排序与选择排序"></a>堆排序与选择排序</h4><blockquote><p>其实堆排序可以看成是选择排序的改进，每次找出最大值放入已排好序的部分。</p></blockquote><ul><li><p>选择排序：每次选出最大值放入已排好序部分后，再对剩余部分全部进行比较，而剩余部分仍然是一个无序的数组 需要比较n-x-1次</p></li><li><p>堆排序：在初建堆时，根节点与孩子节点的大小关系已经确定。每次重建时，比较一下左右孩子的大小，然后将根节点与较大的孩子进行交换，每比较一次，就减少了一半的比较操操作，平均比较次数是二叉树的高度-1，是lbn级别。</p></li></ul><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初建堆  需要对所有根节点进行调整</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> A</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createHeap</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> k;    <span class="comment">//指向需要调整的根节点</span></span><br><span class="line">    <span class="keyword">for</span> (k = n / <span class="number">2</span>; k &gt;= <span class="number">1</span>; k--) &#123;</span><br><span class="line">        swift(A, k, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进行堆的调整</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> A 待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k 调节范围起点   始终指向根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 调整范围终点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swift</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">2</span> * k;</span><br><span class="line">    <span class="keyword">while</span> (p &lt;= n) &#123;     <span class="comment">//只有当k有左孩子时才需要调整</span></span><br><span class="line">        t = p;           <span class="comment">//t先指向左孩子   </span></span><br><span class="line">        <span class="keyword">if</span> (p &lt; n) &#123;     <span class="comment">//如果k有右孩子  需要比较左右孩子的大小</span></span><br><span class="line">            <span class="keyword">if</span> (A[p] &lt; A[p + <span class="number">1</span>]) &#123;    <span class="comment">//如果右孩子大 则需要将t指向右孩子</span></span><br><span class="line">                t = p + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (A[k] &lt; A[t]) &#123;     <span class="comment">//比较根节点与孩子的大小   如果根节点小于孩子节点   则需要交换</span></span><br><span class="line">            temp = A[k];</span><br><span class="line">            A[k] = A[t];</span><br><span class="line">            A[t] = temp;</span><br><span class="line">            k = t;            <span class="comment">//k指向新的根节点</span></span><br><span class="line">            p = <span class="number">2</span> * k;        <span class="comment">//p指向新的根节点的左孩子</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;              <span class="comment">//根节点大于孩子  则已经是大根堆 不必调整  结束</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> A</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    createHeap(A, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &gt; <span class="number">0</span>; i--) &#123;    <span class="comment">//调整堆</span></span><br><span class="line">        A[<span class="number">0</span>] = A[n - <span class="number">1</span>];            <span class="comment">//无序数组要求第一个位置A[0]不存数，便于代码书写与理解</span></span><br><span class="line">        A[n - <span class="number">1</span>] = A[<span class="number">1</span>];</span><br><span class="line">        A[<span class="number">1</span>] = A[<span class="number">0</span>];</span><br><span class="line">        swift(A, <span class="number">1</span>, i - <span class="number">1</span>);    <span class="comment">//只需要</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><blockquote><p>平均时间复杂度$O(n)=nlbn$</p><p>最差时间复杂度$O(n)=nlbn$</p><h5 id="简单分析一下："><a href="#简单分析一下：" class="headerlink" title="简单分析一下："></a>简单分析一下：</h5><p>初建堆要对$n/2$ 个根节点进行调整，每个根节点调整次数（孩子节点的比较次数）平均也就是高度的一半 $\frac{1}{2}lbn$（如果加上根节点与孩子节点的比较差不多就是$lbn$）,   所以初建堆差不多也就是$\frac{1}{4}lbn$  ,调整堆也是类似，相加还是 $nlbn$  级别     （这些数据只是个大概，影响的是系数大小，不会对n哟影响）</p></blockquote><h5 id=""><a href="#" class="headerlink" title=" "></a> </h5><h3 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h3><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><ul><li>合并数组  循环合并，先按照两个子数组的长度为1、2、4、8…进行第合并,每一轮合并都包含多次合并操作。就比如进行长度为8的合并时，就要对{0-7}和{8-15}进行合并 ，对{16-23}和{24-31}进行合并……。</li><li>合并其实就是依次比较两个子数组中的元素大小，将它们另一个临时数组保存，最后把临时数组的内容复制到原数组对应下标。</li></ul><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 划分长度进行合并</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> A   原数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n   数组长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> n)</span> &#123;     <span class="comment">//进行归并</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i = i * <span class="number">2</span>) &#123;     <span class="comment">//依次归并长度为1,2,4,8...的数组</span></span><br><span class="line">        mergePass(A, i, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> A        原数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length   子数组长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n        原数组长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergePass</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> length, <span class="type">int</span> n)</span> &#123;   <span class="comment">//合并长度为length的数组</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i + <span class="number">2</span> * length - <span class="number">1</span> &lt; n; i = i + <span class="number">2</span> * length) &#123;</span><br><span class="line">        merge(A, i, i + length - <span class="number">1</span>, i + <span class="number">2</span> * length - <span class="number">1</span>);   <span class="comment">//下界是i  长度是length 所以mid=i+length-1 上界是mid+length-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i + length - <span class="number">1</span> &lt; n - <span class="number">1</span>) &#123;  <span class="comment">//分界点未超过数组最大下标 也就是但大于一个 小于两个，还是要合并一次</span></span><br><span class="line">        merge(A, i, i + length - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> A</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left    上界  left-mid确定第一个子数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mid     第一个子数组末尾</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> high    下界  mid+1-high确定第二个子数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[high - left + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left, j = mid + <span class="number">1</span>, p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &gt; A[j]) &#123;</span><br><span class="line">            temp[p++] = A[j++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[p++] = A[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        temp[p++] = A[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">        temp[p++] = A[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = left, p = <span class="number">0</span>; i &lt;= high; i++, p++) &#123;</span><br><span class="line">        A[i] = temp[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于代码中的几个细节此处记录以下，老是容易忘记</p><blockquote><p>下界  ：$i$     最初是0</p><p>分界  ：$i+length-1$</p><p>上界  ：$i+2*length-1$</p><p>循环条件  ：上界不超过数组最大下标   $i+2*length-1&lt;n-1$</p><p>循环变量变化  ：上一组被合并的数组的上界加1   $i+2*length-1+1$</p><p>剩余数组大于1个小于两个 ：分界小于最大下标    $i+length-1&lt;n-1$</p><p>第一个函数，是先划分合并的两两子数组长度length，每次都是都整个数组进行合并。</p><p>第二个函数，拿到了子数组长度后，就从0开始，计算相邻两个数组的上下边界（两个数组合在一起的上下界，不是各自的上下界），并传入第三个函数进行合并。第三个函数需要知道被合并的相邻的两个数组的上下界以及二者间的分界。因此第二个函数的循环，以  $i=0$  为下界，i加上两个length长度再减去1 即   <strong>$i+2*length-1$</strong>    计算出上界，而分界就是i加上一个length再减去1即$i+length-1$。循环变量的变化显然就是变为下一组需要被合并的两个数组的下界，也就是上一组被合并的数组的下界加1，即 $i+2*length$。循环条件的判断就是判断被合并的数组的上界是否没有超出原数组的大小。最后要进行一次合并，因为上界如果不满足循环条件，有多种情况，可能就剩一个length长度的数组，或者不足一个，也或者大于一个小于两个，对于最后者这种情况也就是分界点没超过数组长度$i+length-1&lt;n-1$，就需要再次进行合并，那么最后这一次合并的上下界就是 i，n-1。</p></blockquote><h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><blockquote><p>平均时间复杂度$O(n)=nlbn$</p><p>最差时间复杂度$O(n)=nlbn$</p><p>简单分析一下</p><p>合并过程中，因为是对整个数组进行合并，不管是合并子数组的长度为多少，比较次数的规模基本就是n，因为比较的时候本来就是两个数组中的元素取出来依次比较大小，就算运气最好情况也是将另一个数组直接拼接到另一个后面，整体下来还是  <em>$\frac{n}{2}$</em>  。如果数组元素的个数 $n=2^k$  长度划分就有k种 所以 最终时间复杂度就是    $k*n,k=lbn$   所以最终是   $nlbn$       </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法分析与设计基础第3版</title>
      <link href="/posts/35662/"/>
      <url>/posts/35662/</url>
      
        <content type="html"><![CDATA[<h1 id="算法分析与设计基础第3版"><a href="#算法分析与设计基础第3版" class="headerlink" title="算法分析与设计基础第3版"></a>算法分析与设计基础第3版</h1> <embed src="/pdf/算法分析与设计基础3.pdf" width="100%" height="750" type="application/pdf"> ]]></content>
      
      
      <categories>
          
          <category> book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法设计与分析基础笔记</title>
      <link href="/posts/18798/"/>
      <url>/posts/18798/</url>
      
        <content type="html"><![CDATA[<h4 id="递归算法数序分析"><a href="#递归算法数序分析" class="headerlink" title="递归算法数序分析"></a>递归算法数序分析</h4><p>在计算一些常用算法的时间复杂度时，经常涉及到递归，因此也就离不开递归算法的分析</p><h4 id="先看一个例子"><a href="#先看一个例子" class="headerlink" title="先看一个例子"></a>先看一个例子</h4><p>计算函数的时间复杂度</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n*f(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面函数的基本操作就是做乘法，所以计算函数的时间复杂度，其实就是计算<strong>乘法的操作次数。</strong></p><p>假设M(n)代表传入参数n时，函数进行乘法操作的次数，所以有</p><script type="math/tex; mode=display">M(n)= \begin{cases}0\quad\textcolor{orange}{n=0};  \\M(n-1)+1\quad\textcolor{orange}{n>0};\\\end{cases}</script><p>其中加1是指将n乘以f(n-1)。所以根据上面的公式得</p><script type="math/tex; mode=display">\begin{aligned}M(n)&=M(n-1)+1\\&=M(n-2)+1+1\\  &=M(n-3)+1+1+1\\&=M(n-4)+1+1+1+1\\&=···\\&=M(0)+n\\&=n \\  \end{aligned}</script><p>$\begin{aligned}<br> 时间复杂度    \textcolor{red}{O(n)=n}<br>\end{aligned} $</p><h5 id="进行递归算法分析的主要步骤"><a href="#进行递归算法分析的主要步骤" class="headerlink" title="进行递归算法分析的主要步骤"></a>进行递归算法分析的主要步骤</h5><ul><li>确定输入参数的规模</li><li>找出基本操作</li><li>分析相同规模不同输入的算法的最优、最差、平均效率差别</li><li>建立递推关系</li><li>解递推式</li></ul><h4 id="汉诺塔递归算法分析"><a href="#汉诺塔递归算法分析" class="headerlink" title="汉诺塔递归算法分析"></a>汉诺塔递归算法分析</h4><blockquote><p>汉诺塔游戏是将n个盘子通过一个中间柱子，移动到第三个柱子，规则就是小盘子必须在大盘子上面。</p><p><img src="/pic/算法笔记/image-20230801112714469.png" alt="image-20230801112714469"></p><p>问题可以分解成三步，先将上面的n-1个盘子移动到第二根柱子，然后把最大的盘子移动到第三根柱子，最后把n-1个盘子移动到第三根柱子。假设$M(n)$表示将n个盘子移动到第三根柱子需要的步骤数，所以有以下递推式</p><script type="math/tex; mode=display">\begin{aligned} &M(n)=M(n-1)+1+M(n-1) \\&M(n)=2M(n-1)+1\\\\&M(n)= \begin{cases}1\quad\textcolor{orange}{n=1};  \\\\2M(n-1)+1\quad\textcolor{orange}{n>0};\\\end{cases}\end{aligned}</script><p>所以有</p><script type="math/tex; mode=display">\begin{aligned} \textcolor{green}{M(n)}&=2M(n-1)+1\\&=2^2M(n-2)+1+2^1\\&=2^3M(n-3)+1+2^1+2^2\\&=2^4M(n-4)+1+2^1+2^2+2^3\\&=···\\&=2^{n-1}M(1)+1+2+2^2+2^3+···2^{n-2}\\&=2^{n-1}+\frac{1-2^{n-1}}{1-2}\\&=2^{n-1}+2^{n-1}-1\\&=\textcolor{red}{2^n-1}\\\\时间复杂度：\textcolor{red}{O(n)=2^n}\end{aligned}</script></blockquote><h4 id="再看一个例子"><a href="#再看一个例子" class="headerlink" title="再看一个例子"></a>再看一个例子</h4><p>计算时间复杂度</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f(n/<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>这种类型的不能用反向替换方法，如果像 <script type="math/tex">M(n)=M(\frac{n}{2})+1 \\\space\space M(\frac{n}{2})=M(\frac{n}{4})+1</script>  这样替换下去，n不是2的乘方的话，终止不了的。只能在n为2的k次方的情况下求解递推式，所以假设 $n=2^k$ </p></blockquote><p>上公式</p><script type="math/tex; mode=display">\begin{aligned}&令 n=2^k  \\{\space\space}&M(n)=M(\frac{n}{2})+1  \\&=>M(2^k)=M(2^{k-1})+1  \\&M(1)=0\\\end{aligned}\begin{aligned} M(2^k)&=M(2^{k-1})+1 \\&=M(2^{k-2})+1+1\\&=M(2^{k-3})+1+1+1\\&=···\\&=M(2^{k-k})+1+1+···+1+1+1\\&=M(1)+k\\&=\textcolor{red}{k}\\2^k=n {\space\space}即{\space\space}k=log_2n{\space\space} 所以M(n)=log_2n\\时间复杂度：\textcolor{red}{O(n)=log_2n}\end{aligned}</script><p>其他的$\frac{n}{3},\frac{n}{4}$都是一样的道理</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法设计与分析基础笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>project</title>
      <link href="/posts/3210/"/>
      <url>/posts/3210/</url>
      
        <content type="html"><![CDATA[<h4 id="课程预览"><a href="#课程预览" class="headerlink" title="课程预览"></a>课程预览</h4><p><img src="/pic/xuecheng/image-20230731165620030.png" alt="image-20230731165620030"></p><ol><li>前端通过通过点击课程的预览按钮，进入预览页面。前端传递课程id,访问内容管理服务的CoursePublishController,根据课程id，将课程的师资信息，营销信息、基本信息、课程计划信息查询并组装。</li><li>组装后的信息通过freemarker模版引擎将数据渲染到course_template.ftl上，然后返回给前端。</li><li>进入预览页面，查看视频，会发送两次请求，先根据课程id到内容管理服务的CourseOpenController查询课程信息，这里调用的查询方法和第一步一样（没必要差这么全吧）。第二次将课程计划绑定的媒资id发送媒资管理服务的MediaOpenController，查询媒资的访问url，返回前端，以便播放。</li></ol><h4 id="课程提交审核"><a href="#课程提交审核" class="headerlink" title="课程提交审核"></a>课程提交审核</h4><ol><li><p>为实现审核过程中可以修改，设计了课程预发布表，机构人员可以随意修改课程计划、课程基本信息等。提交时，将这些信息组合起来存入预发布表。审核人员审核预发布表中的内容，审核中时，要把预发布表中的审核状态设置为审核中。</p></li><li><p>点击提交审核课程，传递课程id，访问CoursePublishController的方法，将课程的各种信息组装起来存入课程预发布表。存入课程预发布表时要先判断课程信息是否完备，完备后，查询预发布表中信息，看是否存在了，若存在，要看课程的审核状态，如果是审核中，则不可再提交，否则，对存在的信息进行更新操作，不存在就直接插入。然后修改课程基本信息表中的状态为审核中</p></li><li><p>由于进行了预发布表的插入和课程基本信息表的修改，要加上事务控制。</p><p>课程有两个状态一个审核状态{添加课程成功未提交审核   状态为“已提交”，提交审核了  “已提交”，审核通过了  “审核通过”，审核不通过 “审核不通过”}  一个发布状态{目前不清楚}        课程预发布表中有一个审核状态 {提交审核存进来的，初始都为 “已提交”，其他类似，只是没有未提交这个状态}</p></li></ol><h4 id="课程发布"><a href="#课程发布" class="headerlink" title="课程发布"></a>课程发布</h4><h5 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h5><blockquote><p>分布式系统把一个应用系统拆分成分多个可独立部署的微服务，不同微服务间通过网络远程协作（调用）完成的事务操作就是分布式事务。</p><p><strong><em><u>注</u></em></strong></p><p>我之前一直以为只要是连的同一个主机的mysql，@Transaction就能控制事务。只要操作了不同的数据库（这个是指mysql中创建的database，不是指mysql本身，mysql属于数据库管理系统层面）就是分布式事务。<strong><em><u>但注意</u></em></strong>，如果是两个微服务连接的同一个数据库，也属于分布式事务，原因就是跨JVM进程，两个微服务持有了不同的数据库链接进行数据库操作，此时产生分布式事务。</p></blockquote><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><ul><li><p>课程审核成功后，需要将预发布表中的信息复制到发布表。并把预发布表信息删掉</p></li><li><p>课程发布成功后，是可以被搜索到的，并且会有大量用户搜索。因此要把发布成功的信息存到  redis、es、minio。其中redis和es都是存课程信息，minio里面存渲染后的课程静态页面。</p></li><li><p>保存已发布课程的信息涉及到多个操作，涉及到分布式事务，用transaction是不行的。</p></li></ul><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><blockquote><p>首先要考虑是AP还是CP（CAP理论），此处只说保证AP也就是最终一致性的解决方法。</p></blockquote><p>使用XXL-Job+数据库表方案，当把发布的课程存入发布表后，再将课程存入消息表，（消息表与课程表在一个数据库中）此处是可以使用注解保证课程发布成功，消息表一定有数据。然后开启定时任务调度，将消息表中的数据取出依次完成存入redis、es、minio等操作，就算远程调用过程中出现问题，由于是定时调度，并且消息表中的数据还在，故可以保证最终一致性。</p><h5 id="消息SDK组件内容补充"><a href="#消息SDK组件内容补充" class="headerlink" title="消息SDK组件内容补充"></a>消息SDK组件内容补充</h5><blockquote><p>消息组件提供一套解决对消息的增删改查业务的方案，就是向外提供接口，但是不没有具体执行逻辑</p></blockquote><p>消息表中主要就是保存业务的主要信息。如该项目中保存的是课程的id，通过拿到消息表中的课程id，就能查询到课程信息，然后进行缓存操作。消息表中的业务字段有多个，用不上的给该字段存null就行。消息表中还有多个状态字段。因为要存到redis、es、minio，每个阶段完成后给对应字段标记，可以减少重复执行。</p><h4 id="补充关于XXL-Job使用分布式锁防止重复执行方案"><a href="#补充关于XXL-Job使用分布式锁防止重复执行方案" class="headerlink" title="补充关于XXL-Job使用分布式锁防止重复执行方案"></a>补充关于XXL-Job使用分布式锁防止重复执行方案</h4><blockquote><p>xxl-job调度进行视频转码时，用了乐观锁的方案进行避免重复执行，因为视频转码比较消耗CPU，因此应该尽量避免重复执行，而对于缓存操作，不是特别消耗CPU（视频中老师说的）</p></blockquote><h5 id="使用xxl-job时，不是配置了调度策略嘛，为什么还要用乐观锁？"><a href="#使用xxl-job时，不是配置了调度策略嘛，为什么还要用乐观锁？" class="headerlink" title="使用xxl-job时，不是配置了调度策略嘛，为什么还要用乐观锁？"></a>使用xxl-job时，不是配置了调度策略嘛，为什么还要用乐观锁？</h5><p>老师是这样解释的，当执行器与调度器之间的连接发生了中断，xxl-job就检测不到这个执行器了，虽然是发生了中断，但是执行器可能在执行任务了（执行任务时，连接中断了）。由于xxl-job是动态扩容，因此会对其他执行器进行重新排序（代码每个执行器就是根据自己的序号进行对应任务的处理），那么就导致其他执行器会调度执行（在断开连接的执行器执行完任务，删除任务表中数据之前）任务表中的任务，就有可能重复执行。</p><h4 id="页面静态化"><a href="#页面静态化" class="headerlink" title="页面静态化"></a>页面静态化</h4><blockquote><p>对于课程预览页面，用户搜索到就能查看，如果每次都访问tomcat服务器查询数据渲染返回，会使服务器压力过大，因此需要对课程预览页进行静态化并存储到minio。</p></blockquote><p>因为课程页面的静态化属于内容管理服务，而静态页面上传到minio属于文件服务，生成的静态页面在内存中，并没有在数据库存，不能通过发两次请求来实现。因此要进行远程调用。</p><p>内容管理服务调用媒资服务，那么就要在内容管理服务编写Feign接口，编写规则就是将媒资相关controller接口方法copy过来，写到feign接口中，接口要通过注解指定媒资服务的名称，启动类要加上开启远程调用注解，</p><h4 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h4><p>熔断降级的相同点都是为了解决微服务系统崩溃的问题，但它们是两个不同的技术手段，两者又存在联系。</p><p>熔断：</p><p>当下游服务异常而断开与上游服务的交互，它就相当于保险丝，下游服务异常触发了熔断，从而保证上游服务不受影响。</p><p>降级：</p><p>当下游服务异常触发熔断后，上游服务就不再去调用异常的微服务而是执行了降级处理逻辑，这个降级处理逻辑可以是本地一个单独的方法。</p><h4 id="存入索引库（ES）"><a href="#存入索引库（ES）" class="headerlink" title="存入索引库（ES）"></a>存入索引库（ES）</h4><p>存入索引库这不操作，可以在课程发布成功，插入到发布表的地方通过编写代码实现，但这样会让业务耦合。实现数据库与索引库同步有很多办法，包括使用  消息队列mq，XXL-Job定时调度、还有阿里Canal，它是通过解析mysql的一个日志文件，来判断数据库进行了哪些的操作，然后将这写操作同步到索引库。因为该项目从课程发布那一节之后，就选择的是用消息sdk来实现，也就是存入es、redis、上传minio都是从数据的消息表里面读，然后进行相应同步。</p><h4 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h4><p>之前的视频转码是用的是xxl-job，但没有用sdk组件，媒资数据库有个任务表，是从那个任务表里面拿到任务，然后进行转码处理。而在媒资之后，用到xxl-job的地方就是课程发布后，缓存的同步，有静态页面的上传，es的同步，redis的同步。</p>]]></content>
      
      
      
        <tags>
            
            <tag> xuecheng </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/posts/d87f7e0c/"/>
      <url>/posts/d87f7e0c/</url>
      
        <content type="html"><![CDATA[<h3 id="这是测试用例"><a href="#这是测试用例" class="headerlink" title="这是测试用例"></a>这是测试用例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;hello java&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="ReentrantLock和Synchronized的区别"><a href="#ReentrantLock和Synchronized的区别" class="headerlink" title="ReentrantLock和Synchronized的区别"></a>ReentrantLock和Synchronized的区别</h3><ul><li>ReentrantLock是一个类。synchronized是一个Java关键字</li><li>前者可重入 后者不可重入</li><li>前者获取锁失败可以返回  后者会阻塞</li><li>前者需要手动释放锁  后者自动释放锁</li></ul><h4 id="如何在4小时内睡满8小时"><a href="#如何在4小时内睡满8小时" class="headerlink" title="如何在4小时内睡满8小时"></a>如何在4小时内睡满8小时</h4><blockquote><p>这是一个智障问题</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156/"/>
      <url>/posts/4a17b156/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
